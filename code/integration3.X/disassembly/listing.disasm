Disassembly Listing for integration2
Generated From:
H:/ecen4013/integration2/integration2.X/dist/default/production/integration2.X.production.elf
Apr 27, 2014 11:09:06 PM

---  H:/ecen4013/integration2/integration2.X/spi_12832.c  -----------------------------------------------
1:                 /*
2:                  * header for SPI to oled screen... driver chip 12832 (pulled from internet)
3:                  *
4:                  */
5:                 
6:                 #include <p24HJ64GP502.h>
7:                 
8:                 #include "logics.h"
9:                 
10:                
11:                //--------------------------------------------------------------------------
12:                void oled_command(unsigned char Data)
13:                {
00278E  FA0004     LNK #0x4
002790  984720     MOV.B W0, [W14+2]
14:                    SPI1BUF = Data;
002792  90402E     MOV.B [W14+2], W0
002794  FB8000     ZE W0, W0
002796  881240     MOV W0, SPI1BUF
15:                    oled_d_c = 0;   //D/C
002798  A9C2CD     BCLR 0x2CD, #6
16:                    int i;
17:                    // Nops because SPI TBF bit is broken, see silicon errata
18:                    for(i = 0; i < 40; i++) {
00279A  EB0000     CLR W0
00279C  780F00     MOV W0, [W14]
00279E  370002     BRA 0x27A4
0027A2  E80F1E     INC [W14], [W14]
0027A4  200270     MOV #0x27, W0
0027A6  78009E     MOV [W14], W1
0027A8  508F80     SUB W1, W0, [W15]
0027AA  34FFFA     BRA LE, 0x27A0
19:                        Nop();
0027A0  000000     NOP
20:                    }
21:                }
0027AC  FA8000     ULNK
0027AE  060000     RETURN
22:                //--------------------------------------------------------------------------
23:                //--------------------------------------------------------------------------
24:                
25:                void oled_data(unsigned char Data)
26:                {
0027B0  FA0004     LNK #0x4
0027B2  984720     MOV.B W0, [W14+2]
27:                    SPI1BUF = Data;
0027B4  90402E     MOV.B [W14+2], W0
0027B6  FB8000     ZE W0, W0
0027B8  881240     MOV W0, SPI1BUF
28:                    oled_d_c = 1;   //D/C
0027BA  A8C2CD     BSET 0x2CD, #6
29:                    int i;
30:                    // Nops because SPI TBF bit is broken, see silicon errata
31:                    for(i = 0; i < 40; i++) {
0027BC  EB0000     CLR W0
0027BE  780F00     MOV W0, [W14]
0027C0  370002     BRA 0x27C6
0027C4  E80F1E     INC [W14], [W14]
0027C6  200270     MOV #0x27, W0
0027C8  78009E     MOV [W14], W1
0027CA  508F80     SUB W1, W0, [W15]
0027CC  34FFFA     BRA LE, 0x27C2
32:                        Nop();
0027C2  000000     NOP
33:                    }
34:                }
0027CE  FA8000     ULNK
0027D0  060000     RETURN
35:                //--------------------------------------------------------------------------
36:                //--------------------------------------------------------------------------
37:                
38:                void Set_Start_Column_12832(unsigned char d)
39:                {
0027D2  FA0002     LNK #0x2
0027D4  784F00     MOV.B W0, [W14]
40:                	oled_command(0x00+d%16);		// Set Lower Column Start Address for Page Addressing Mode
0027D6  78409E     MOV.B [W14], W1
0027D8  60C06F     AND.B W1, #0xF, W0
0027DA  07FFD9     RCALL oled_command
41:                						//   Default => 0x00
42:                	oled_command(0x10+d/16);		// Set Higher Column Start Address for Page Addressing Mode
0027DC  78409E     MOV.B [W14], W1
0027DE  FB8001     ZE W1, W0
0027E0  DE0044     LSR W0, #4, W0
0027E2  784000     MOV.B W0, W0
0027E4  404070     ADD.B W0, #0x10, W0
0027E6  07FFD3     RCALL oled_command
43:                						//   Default => 0x10
44:                }
0027E8  FA8000     ULNK
0027EA  060000     RETURN
45:                //--------------------------------------------------------------------------
46:                
47:                void Set_Addressing_Mode_12832(unsigned char d)
48:                {
0027EC  FA0002     LNK #0x2
0027EE  784F00     MOV.B W0, [W14]
49:                	oled_command(0x20);			// Set Memory Addressing Mode
0027F0  B3C200     MOV #0x20, W0
0027F2  07FFCD     RCALL oled_command
50:                	oled_command(d);			//   Default => 0x02
0027F4  78401E     MOV.B [W14], W0
0027F6  07FFCB     RCALL oled_command
51:                						//     0x00 => Horizontal Addressing Mode
52:                						//     0x01 => Vertical Addressing Mode
53:                						//     0x02 => Page Addressing Mode
54:                }
0027F8  FA8000     ULNK
0027FA  060000     RETURN
55:                //--------------------------------------------------------------------------
56:                
57:                void Set_Column_Address_12832(unsigned char a, unsigned char b)
58:                {
0027FC  FA0002     LNK #0x2
0027FE  784F00     MOV.B W0, [W14]
002800  984711     MOV.B W1, [W14+1]
59:                	oled_command(0x21);			// Set Column Address
002802  B3C210     MOV #0x21, W0
002804  07FFC4     RCALL oled_command
60:                	oled_command(a);			//   Default => 0x00 (Column Start Address)
002806  78401E     MOV.B [W14], W0
002808  07FFC2     RCALL oled_command
61:                	oled_command(b);			//   Default => 0x83 (Column End Address)
00280A  90401E     MOV.B [W14+1], W0
00280C  07FFC0     RCALL oled_command
62:                }
00280E  FA8000     ULNK
002810  060000     RETURN
63:                //--------------------------------------------------------------------------
64:                
65:                void Set_Page_Address_12832(unsigned char a, unsigned char b)
66:                {
002812  FA0002     LNK #0x2
002814  784F00     MOV.B W0, [W14]
002816  984711     MOV.B W1, [W14+1]
67:                	oled_command(0x22);			// Set Page Address
002818  B3C220     MOV #0x22, W0
00281A  07FFB9     RCALL oled_command
68:                	oled_command(a);			//   Default => 0x00 (Page Start Address)
00281C  78401E     MOV.B [W14], W0
00281E  07FFB7     RCALL oled_command
69:                	oled_command(b);			//   Default => 0x07 (Page End Address)
002820  90401E     MOV.B [W14+1], W0
002822  07FFB5     RCALL oled_command
70:                }
002824  FA8000     ULNK
002826  060000     RETURN
71:                //--------------------------------------------------------------------------
72:                
73:                void Set_Start_Line_12832(unsigned char d)
74:                {
002828  FA0002     LNK #0x2
00282A  784F00     MOV.B W0, [W14]
75:                	oled_command(0x40|d);			// Set Display Start Line
00282C  B3C400     MOV #0x40, W0
00282E  70401E     IOR.B W0, [W14], W0
002830  07FFAE     RCALL oled_command
76:                						//   Default => 0x40 (0x00)
77:                }
002832  FA8000     ULNK
002834  060000     RETURN
78:                //--------------------------------------------------------------------------
79:                
80:                void Set_Contrast_Control_12832(unsigned char d)
81:                {
002836  FA0002     LNK #0x2
002838  784F00     MOV.B W0, [W14]
82:                	oled_command(0x81);			// Set Contrast Control for Bank 0
00283A  B3C810     MOV #0x81, W0
00283C  07FFA8     RCALL oled_command
83:                	oled_command(d);			//   Default => 0x80
00283E  78401E     MOV.B [W14], W0
002840  07FFA6     RCALL oled_command
84:                }
002842  FA8000     ULNK
002844  060000     RETURN
85:                //--------------------------------------------------------------------------
86:                
87:                void Set_Area_Brightness_12832(unsigned char d)
88:                {
002846  FA0002     LNK #0x2
002848  784F00     MOV.B W0, [W14]
89:                	oled_command(0x82);			// Set Brightness for Area Color Banks
00284A  B3C820     MOV #0x82, W0
00284C  07FFA0     RCALL oled_command
90:                	oled_command(d);			//   Default => 0x80
00284E  78401E     MOV.B [W14], W0
002850  07FF9E     RCALL oled_command
91:                }
002852  FA8000     ULNK
002854  060000     RETURN
92:                //--------------------------------------------------------------------------
93:                
94:                void Set_Segment_Remap_12832(unsigned char d)
95:                {
002856  FA0002     LNK #0x2
002858  784F00     MOV.B W0, [W14]
96:                	oled_command(0xA0|d);			// Set Segment Re-Map
00285A  B3CA00     MOV #0xA0, W0
00285C  70401E     IOR.B W0, [W14], W0
00285E  07FF97     RCALL oled_command
97:                						//   Default => 0xA0
98:                						//     0xA0 (0x00) => Column Address 0 Mapped to SEG0
99:                						//     0xA1 (0x01) => Column Address 0 Mapped to SEG131
100:               }
002860  FA8000     ULNK
002862  060000     RETURN
101:               //--------------------------------------------------------------------------
102:               
103:               void Set_Entire_Display_12832(unsigned char d)
104:               {
002864  FA0002     LNK #0x2
002866  784F00     MOV.B W0, [W14]
105:               	oled_command(0xA4|d);			// Set Entire Display On / Off
002868  B3CA40     MOV #0xA4, W0
00286A  70401E     IOR.B W0, [W14], W0
00286C  07FF90     RCALL oled_command
106:               						//   Default => 0xA4
107:               						//     0xA4 (0x00) => Normal Display
108:               						//     0xA5 (0x01) => Entire Display On
109:               }
00286E  FA8000     ULNK
002870  060000     RETURN
110:               //--------------------------------------------------------------------------
111:               
112:               void Set_Inverse_Display_12832(unsigned char d)
113:               {
002872  FA0002     LNK #0x2
002874  784F00     MOV.B W0, [W14]
114:               	oled_command(0xA6|d);			// Set Inverse Display On/Off
002876  B3CA60     MOV #0xA6, W0
002878  70401E     IOR.B W0, [W14], W0
00287A  07FF89     RCALL oled_command
115:               						//   Default => 0xA6
116:               						//     0xA6 (0x00) => Normal Display
117:               						//     0xA7 (0x01) => Inverse Display On
118:               }
00287C  FA8000     ULNK
00287E  060000     RETURN
119:               //--------------------------------------------------------------------------
120:               
121:               void Set_Multiplex_Ratio_12832(unsigned char d)
122:               {
002880  FA0002     LNK #0x2
002882  784F00     MOV.B W0, [W14]
123:               	oled_command(0xA8);			// Set Multiplex Ratio
002884  B3CA80     MOV #0xA8, W0
002886  07FF83     RCALL oled_command
124:               	oled_command(d);			//   Default => 0x3F (1/64 Duty)
002888  78401E     MOV.B [W14], W0
00288A  07FF81     RCALL oled_command
125:               }
00288C  FA8000     ULNK
00288E  060000     RETURN
126:               //--------------------------------------------------------------------------
127:               
128:               void Set_Dim_Mode_12832(unsigned char a, unsigned char b)
129:               {
002890  FA0002     LNK #0x2
002892  784F00     MOV.B W0, [W14]
002894  984711     MOV.B W1, [W14+1]
130:               	oled_command(0xAB);			// Set Dim Mode Configuration
002896  B3CAB0     MOV #0xAB, W0
002898  07FF7A     RCALL oled_command
131:               	oled_command(0X00);			//           => (Dummy Write for First Parameter)
00289A  EB4000     CLR.B W0
00289C  07FF78     RCALL oled_command
132:               	oled_command(a);			//   Default => 0x80 (Contrast Control for Bank 0)
00289E  78401E     MOV.B [W14], W0
0028A0  07FF76     RCALL oled_command
133:               	oled_command(b);			//   Default => 0x80 (Brightness for Area Color Banks)
0028A2  90401E     MOV.B [W14+1], W0
0028A4  07FF74     RCALL oled_command
134:               	oled_command(0xAC);			// Set Display On in Dim Mode
0028A6  B3CAC0     MOV #0xAC, W0
0028A8  07FF72     RCALL oled_command
135:               }
0028AA  FA8000     ULNK
0028AC  060000     RETURN
136:               //--------------------------------------------------------------------------
137:               
138:               void Set_Master_Config_12832(unsigned char d)
139:               {
0028AE  FA0002     LNK #0x2
0028B0  784F00     MOV.B W0, [W14]
140:               	oled_command(0xAD);			// Set Master Configuration
0028B2  B3CAD0     MOV #0xAD, W0
0028B4  07FF6C     RCALL oled_command
141:               	oled_command(0x8E|d);			//   Default => 0x8E
0028B6  B3C8E0     MOV #0x8E, W0
0028B8  70401E     IOR.B W0, [W14], W0
0028BA  07FF69     RCALL oled_command
142:               						//     0x8E (0x00) => Select External VCC Supply
143:               						//     0x8F (0x01) => Select Internal DC/DC Voltage Converter
144:               }
0028BC  FA8000     ULNK
0028BE  060000     RETURN
145:               //--------------------------------------------------------------------------
146:               
147:               void Set_Display_On_Off_12832(unsigned char d)
148:               {
0028C0  FA0002     LNK #0x2
0028C2  784F00     MOV.B W0, [W14]
149:               	oled_command(0xAE|d);			// Set Display On/Off
0028C4  B3CAE0     MOV #0xAE, W0
0028C6  70401E     IOR.B W0, [W14], W0
0028C8  07FF62     RCALL oled_command
150:               						//   Default => 0xAE
151:               						//     0xAE (0x00) => Display Off
152:               						//     0xAF (0x01) => Display On
153:               }
0028CA  FA8000     ULNK
0028CC  060000     RETURN
154:               //--------------------------------------------------------------------------
155:               
156:               void Set_Start_Page_12832(unsigned char d)
157:               {
0028CE  FA0002     LNK #0x2
0028D0  784F00     MOV.B W0, [W14]
158:               	oled_command(0xB0|d);			// Set Page Start Address for Page Addressing Mode
0028D2  B3CB00     MOV #0xB0, W0
0028D4  70401E     IOR.B W0, [W14], W0
0028D6  07FF5B     RCALL oled_command
159:               						//   Default => 0xB0 (0x00)
160:               }
0028D8  FA8000     ULNK
0028DA  060000     RETURN
161:               //--------------------------------------------------------------------------
162:               
163:               void Set_Common_Remap_12832(unsigned char d)
164:               {
0028DC  FA0002     LNK #0x2
0028DE  784F00     MOV.B W0, [W14]
165:               	oled_command(0xC0|d);			// Set COM Output Scan Direction
0028E0  B3CC00     MOV #0xC0, W0
0028E2  70401E     IOR.B W0, [W14], W0
0028E4  07FF54     RCALL oled_command
166:               						//   Default => 0xC0
167:               						//     0xC0 (0x00) => Scan from COM0 to 63
168:               						//     0xC8 (0x08) => Scan from COM63 to 0
169:               }
0028E6  FA8000     ULNK
0028E8  060000     RETURN
170:               //--------------------------------------------------------------------------
171:               
172:               void Set_Display_Offset_12832(unsigned char d)
173:               {
0028EA  FA0002     LNK #0x2
0028EC  784F00     MOV.B W0, [W14]
174:               	oled_command(0xD3);			// Set Display Offset
0028EE  B3CD30     MOV #0xD3, W0
0028F0  07FF4E     RCALL oled_command
175:               	oled_command(d);			//   Default => 0x00
0028F2  78401E     MOV.B [W14], W0
0028F4  07FF4C     RCALL oled_command
176:               }
0028F6  FA8000     ULNK
0028F8  060000     RETURN
177:               //--------------------------------------------------------------------------
178:               
179:               void Set_Display_Clock_12832(unsigned char d)
180:               {
0028FA  FA0002     LNK #0x2
0028FC  784F00     MOV.B W0, [W14]
181:               	oled_command(0xD5);			// Set Display Clock Divide Ratio / Oscillator Frequency
0028FE  B3CD50     MOV #0xD5, W0
002900  07FF46     RCALL oled_command
182:               	oled_command(d);			//   Default => 0x70
002902  78401E     MOV.B [W14], W0
002904  07FF44     RCALL oled_command
183:               						//     D[3:0] => Display Clock Divider
184:               						//     D[7:4] => Oscillator Frequency
185:               }
002906  FA8000     ULNK
002908  060000     RETURN
186:               //--------------------------------------------------------------------------
187:               
188:               void Set_Area_Color_12832(unsigned char d)
189:               {
00290A  FA0002     LNK #0x2
00290C  784F00     MOV.B W0, [W14]
190:               	oled_command(0xD8);			// Set Area Color Mode On/Off & Low Power Display Mode
00290E  B3CD80     MOV #0xD8, W0
002910  07FF3E     RCALL oled_command
191:               	oled_command(d);			//   Default => 0x00 (Monochrome Mode & Normal Power Display Mode)
002912  78401E     MOV.B [W14], W0
002914  07FF3C     RCALL oled_command
192:               }
002916  FA8000     ULNK
002918  060000     RETURN
193:               //--------------------------------------------------------------------------
194:               
195:               void Set_Precharge_Period_12832(unsigned char d)
196:               {
00291A  FA0002     LNK #0x2
00291C  784F00     MOV.B W0, [W14]
197:               	oled_command(0xD9);			// Set Pre-Charge Period
00291E  B3CD90     MOV #0xD9, W0
002920  07FF36     RCALL oled_command
198:               	oled_command(d);			//   Default => 0x22 (2 Display Clocks [Phase 2] / 2 Display Clocks [Phase 1])
002922  78401E     MOV.B [W14], W0
002924  07FF34     RCALL oled_command
199:               						//     D[3:0] => Phase 1 Period in 1~15 Display Clocks
200:               						//     D[7:4] => Phase 2 Period in 1~15 Display Clocks
201:               }
002926  FA8000     ULNK
002928  060000     RETURN
202:               //--------------------------------------------------------------------------
203:               
204:               void Set_Common_Config_12832(unsigned char d)
205:               {
00292A  FA0002     LNK #0x2
00292C  784F00     MOV.B W0, [W14]
206:               	oled_command(0xDA);			// Set COM Pins Hardware Configuration
00292E  B3CDA0     MOV #0xDA, W0
002930  07FF2E     RCALL oled_command
207:               	oled_command(0x02|d);			//   Default => 0x12 (0x10)
002932  78401E     MOV.B [W14], W0
002934  A01400     BSET.B W0, #1
002936  07FF2B     RCALL oled_command
208:               						//     Alternative COM Pin Configuration
209:               						//     Disable COM Left/Right Re-Map
210:               }
002938  FA8000     ULNK
00293A  060000     RETURN
211:               //--------------------------------------------------------------------------
212:               
213:               void Set_VCOMH_12832(unsigned char d)
214:               {
00293C  FA0002     LNK #0x2
00293E  784F00     MOV.B W0, [W14]
215:               	oled_command(0xDB);			// Set VCOMH Deselect Level
002940  B3CDB0     MOV #0xDB, W0
002942  07FF25     RCALL oled_command
216:               	oled_command(d);			//   Default => 0x34 (0.77*VCC)
002944  78401E     MOV.B [W14], W0
002946  07FF23     RCALL oled_command
217:               }
002948  FA8000     ULNK
00294A  060000     RETURN
218:               //--------------------------------------------------------------------------
219:               
220:               void Set_Read_Modify_Write_12832(unsigned char d)
221:               {
00294C  FA0002     LNK #0x2
00294E  784F00     MOV.B W0, [W14]
222:               	oled_command(0xE0|d);			// Set Read Modify Write Mode
002950  B3CE00     MOV #0xE0, W0
002952  70401E     IOR.B W0, [W14], W0
002954  07FF1C     RCALL oled_command
223:               						//   Default => 0xE0
224:               						//     0xE0 (0x00) => Enter Read Modify Write
225:               						//     0xEE (0x0E) => Exit Read Modify Write
226:               }
002956  FA8000     ULNK
002958  060000     RETURN
227:               //--------------------------------------------------------------------------
228:               
229:               void Set_NOP_12832()
230:               {
00295A  FA0000     LNK #0x0
231:               	oled_command(0xE3);			// Command for No Operation
00295C  B3CE30     MOV #0xE3, W0
00295E  07FF17     RCALL oled_command
232:               }
002960  FA8000     ULNK
002962  060000     RETURN
233:               
234:               //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
235:               //  Bank Color & Look Up Table Setting (Partial Screen)
236:               //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
237:               void Set_LUT_12832(unsigned char a, unsigned char b, unsigned char c, unsigned char d)
238:               {
002964  FA0004     LNK #0x4
002966  784F00     MOV.B W0, [W14]
002968  984711     MOV.B W1, [W14+1]
00296A  984722     MOV.B W2, [W14+2]
00296C  984733     MOV.B W3, [W14+3]
239:               	oled_command(0x91);			// Define Look Up Table of Area Color
00296E  B3C910     MOV #0x91, W0
002970  07FF0E     RCALL oled_command
240:               	oled_command(a);			//   Define Bank 0 Pulse Width
002972  78401E     MOV.B [W14], W0
002974  07FF0C     RCALL oled_command
241:               	oled_command(b);			//   Define Color A Pulse Width
002976  90401E     MOV.B [W14+1], W0
002978  07FF0A     RCALL oled_command
242:               	oled_command(c);			//   Define Color B Pulse Width
00297A  90402E     MOV.B [W14+2], W0
00297C  07FF08     RCALL oled_command
243:               	oled_command(d);			//   Define Color C Pulse Width
00297E  90403E     MOV.B [W14+3], W0
002980  07FF06     RCALL oled_command
244:               }
002982  FA8000     ULNK
002984  060000     RETURN
245:               
246:               void Set_Bank_Color_12832()
247:               {
002986  FA0000     LNK #0x0
248:               	oled_command(0x92);			// Define Area Color for Bank 1~16 (Page 0)
002988  B3C920     MOV #0x92, W0
00298A  07FF01     RCALL oled_command
249:               	oled_command(0x00);			//   Define Bank 1~4 as Color A
00298C  EB4000     CLR.B W0
00298E  07FEFF     RCALL oled_command
250:               	oled_command(0x55);			//   Define Bank 5~8 as Color B
002990  B3C550     MOV #0x55, W0
002992  07FEFD     RCALL oled_command
251:               	oled_command(0xAA);			//   Define Bank 9~12 as Color C
002994  B3CAA0     MOV #0xAA, W0
002996  07FEFB     RCALL oled_command
252:               	oled_command(0xFF);			//   Define Bank 13~16 as Color D
002998  EBC000     SETM.B W0
00299A  07FEF9     RCALL oled_command
253:               
254:               	oled_command(0x93);			// Define Area Color for Bank 17~32 (Page 1)
00299C  B3C930     MOV #0x93, W0
00299E  07FEF7     RCALL oled_command
255:               	oled_command(0xFF);			//   Define Bank 17~32 as Color D
0029A0  EBC000     SETM.B W0
0029A2  07FEF5     RCALL oled_command
256:               	oled_command(0xFF);
0029A4  EBC000     SETM.B W0
0029A6  07FEF3     RCALL oled_command
257:               	oled_command(0xFF);
0029A8  EBC000     SETM.B W0
0029AA  07FEF1     RCALL oled_command
258:               	oled_command(0xFF);
0029AC  EBC000     SETM.B W0
0029AE  07FEEF     RCALL oled_command
259:               }
0029B0  FA8000     ULNK
0029B2  060000     RETURN
---  H:/ecen4013/integration2/integration2.X/oled.c  ----------------------------------------------------
1:                 /*
2:                  * oled.c - SPI interface to OLED screen for integration phase
3:                  *
4:                  * Original by Blmcart
5:                  *
6:                  * Modified by Colt Wilkens
7:                  *
8:                  */
9:                 
10:                #include <p24HJ64GP502.h>
11:                #include <stdio.h>
12:                #include <stdlib.h>
13:                
14:                #include "logics.h"
15:                #include "spi_12832.h"
16:                
17:                /*#include <spi.h>
18:                #include <delay.h>
19:                #include <uart.h>
20:                
21:                #pragma config FNOSC = FRC              // Oscillator Mode (Internal Fast RC (FRC))
22:                #pragma config IESO = OFF               // Internal External Switch Over Mode (Start-up device with user-selected oscillator source)
23:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable (Watchdog timer enabled/disabled by user software)
24:                
25:                #define FCY 3685000
26:                #define BAUDRATE 9600
27:                #define BRGVAL ((FCY/BAUDRATE)/16)-1
28:                */
29:                //------------------------------------------------------------------------------
30:                // image arrays generated by LCD Assistant
31:                // http://en.radzio.dxp.pl/bitmap_converter/
32:                //------------------------------------------------------------------------------
33:                const unsigned char logo [] = {
34:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xC0, 0xC0,
35:                0xE0, 0xE0, 0xF0, 0xF0, 0xF8, 0xFC, 0xDC, 0x1C, 0x7C, 0x0E, 0xFE, 0xFE, 0xFE, 0x8E, 0x26, 0x76,
36:                0x26, 0x8E, 0xFF, 0xFE, 0xF6, 0x66, 0x86, 0xE6, 0xEE, 0xFE, 0x7C, 0x1C, 0x58, 0x98, 0xB0, 0xF0,
37:                0xE0, 0xE0, 0xC0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
38:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x40, 0xC0, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00,
39:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
40:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
41:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
42:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0xF0, 0xF8, 0xFC, 0xFF, 0xFF, 0xFF, 0xFD, 0xF8,
43:                0xE1, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
44:                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF9, 0xFA, 0xFE, 0xFF, 0xE7,
45:                0xC3, 0xD8, 0xDC, 0xD9, 0xE3, 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00,
46:                0x00, 0x00, 0x00, 0x00, 0x20, 0x3E, 0x09, 0x08, 0x09, 0x0E, 0x30, 0x00, 0x3F, 0x21, 0x21, 0x21,
47:                0x1E, 0x00, 0x00, 0x27, 0x25, 0x29, 0x39, 0x00, 0x00, 0x1E, 0x25, 0x25, 0x27, 0x00, 0x00, 0x3F,
48:                0x02, 0x01, 0x01, 0x3E, 0x00, 0x01, 0x1F, 0x21, 0x21, 0x00, 0x1E, 0x25, 0x25, 0x27, 0x00, 0x00,
49:                0x1E, 0x25, 0x25, 0x27, 0x00, 0x00, 0x27, 0x25, 0x29, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
50:                0x00, 0x80, 0xF0, 0xF8, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F,
51:                0x7F, 0x3F, 0x8F, 0xC7, 0x47, 0xF3, 0xF3, 0xB9, 0xE9, 0x7D, 0xDD, 0x7B, 0xF3, 0xB3, 0x1B, 0x89,
52:                0x85, 0x44, 0x44, 0x25, 0x29, 0x4B, 0x49, 0x49, 0x45, 0x45, 0x29, 0x29, 0x23, 0x13, 0x87, 0x0F,
53:                0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF8, 0xE0,
54:                0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
55:                0x00, 0x00, 0x40, 0x40, 0xC0, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
56:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
57:                0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
58:                0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x80, 0x1E, 0xF6, 0xF6,
59:                0xBF, 0xFD, 0xFF, 0xED, 0x7F, 0xFB, 0xDE, 0xFF, 0x7D, 0xEF, 0xFB, 0xFF, 0x5D, 0x7F, 0x33, 0x18,
60:                0x4C, 0x4C, 0x26, 0x12, 0x89, 0x49, 0x52, 0x52, 0x4A, 0x2A, 0x2A, 0x2A, 0x29, 0xA5, 0x94, 0x92,
61:                0x88, 0x41, 0x07, 0x1F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
62:                0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
63:                0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x1E, 0x15, 0x15, 0x17, 0x00, 0x00, 0x1D, 0x15,
64:                0x15, 0x1F, 0x10, 0x00, 0x1E, 0x01, 0x01, 0x1F, 0x01, 0x01, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x12,
65:                0x12, 0x12, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
66:                };
67:                
68:                const unsigned char fire [] = {
69:                /*0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
70:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1C, 0x3C, 0x3C, 0x7C, 0xFC, 0xFC, 0xF8,
71:                0xF8, 0x78, 0x70, 0x70, 0x7E, 0xFF, 0xFF, 0x0E, 0x1F, 0x1F, 0x0F, 0x0F, 0x1F, 0x3C, 0x3E, 0x3F,
72:                0x0F, 0x1F, 0x3F, 0x3E, 0x3E, 0x1E, 0x0F, 0x07, 0x07, 0x03, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07,
73:                0x07, 0x03, 0x03, 0x07, 0x0F, 0x0F, 0x0F, 0x0F, 0x07, 0x03, 0x03, 0x0F, 0x1F, 0x1E, 0x1C, 0x1E,
74:                0x1E, 0x0F, 0x0F, 0x07, 0x1F, 0x3E, 0x7C, 0xF0, 0xE0, 0xFC, 0xFE, 0xFC, 0x3C, 0xF8, 0xF0, 0xF0,
75:                0xF0, 0xE0, 0xC0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
76:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
77:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
78:                0x00, 0x00, 0x40, 0xE0, 0xF0, 0xF0, 0xF0, 0xF8, 0xF8, 0xB8, 0x3C, 0x1C, 0x1C, 0x1C, 0x1F, 0x1F,
79:                0x1F, 0x1E, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xC7, 0xC7, 0xC7,
80:                0x07, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xC7, 0xEF,
81:                0xFF, 0x7F, 0x38, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0x00,
82:                0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03,
83:                0x1B, 0x3F, 0xBF, 0xBF, 0xFF, 0xFF, 0xFF, 0xEF, 0xEF, 0xC7, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00,
84:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
85:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
86:                0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC1, 0xE1, 0xF3, 0xF7, 0x7F, 0x3F, 0x3E, 0x1E, 0x1C, 0x00,
87:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x3F, 0x3F, 0x01, 0x81, 0x81, 0x01,
88:                0x00, 0x00, 0x00, 0x3F, 0x3F, 0x3F, 0x3F, 0x00, 0x00, 0x3F, 0x3F, 0x3F, 0x3F, 0x01, 0x03, 0x0F,
89:                0x3F, 0x3E, 0x38, 0x30, 0x00, 0x3F, 0x3F, 0x3F, 0x3F, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x00,
90:                0x00, 0x39, 0x3B, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x87, 0x8F, 0x8F,
91:                0xCF, 0xDF, 0xDF, 0xFF, 0xFB, 0xFB, 0xFB, 0xFB, 0xF3, 0xF3, 0xE3, 0xE0, 0xC0, 0x80, 0x00, 0x00,
92:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
93:                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
94:                0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x0F, 0x0F, 0x0F, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
95:                0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x1E, 0x1C, 0x3C, 0x3E, 0x3E, 0x3F, 0x07, 0x07, 0x07, 0x1F,
96:                0x3E, 0x3C, 0x78, 0xF8, 0xFE, 0xFF, 0x3F, 0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0xF8, 0xFC, 0xFC, 0x1E,
97:                0x1E, 0x1C, 0x3C, 0x78, 0xF0, 0xF0, 0xFC, 0xFE, 0x3E, 0x1E, 0x3C, 0x78, 0xF8, 0xF8, 0xFE, 0xFF,
98:                0x0F, 0x07, 0x07, 0x07, 0x0F, 0x1E, 0x7E, 0xFC, 0xFC, 0xFE, 0x1E, 0x0F, 0x07, 0x07, 0x07, 0x03,
99:                0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
100:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00*/
101:               0x00, 0x20, 0x20, 0x20, 0x20, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x0C, 0x08, 0x00, 0xE0,
102:               0xA0, 0xA0, 0x23, 0x02, 0x22, 0xE4, 0x24, 0x0C, 0xE8, 0xA0, 0xA0, 0x40, 0x00, 0xE1, 0xA1, 0xA2,
103:               0x22, 0x02, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x20, 0x60, 0xC0, 0x80, 0xA0, 0xE0, 0xC0, 0x80, 0x80,
104:               0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xA0, 0xE0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00,
105:               0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x0A, 0x8A, 0x8A, 0xC9, 0x49, 0x49, 0x28, 0x20, 0x20, 0x27,
106:               0x80, 0x80, 0x40, 0x40, 0x44, 0x47, 0x44, 0x20, 0x27, 0x00, 0x00, 0x87, 0x80, 0x47, 0x44, 0x44,
107:               0x44, 0x20, 0x25, 0x10, 0x10, 0x00, 0x00, 0x04, 0x06, 0x03, 0x01, 0x05, 0x07, 0x03, 0x01, 0x01,
108:               0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x07, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00
109:               };
110:               
111:               const unsigned char dead [] = {
112:               /*0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
113:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
114:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
115:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
116:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
117:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
118:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
119:               0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
120:               0x00, 0x00, 0x02, 0x06, 0x1E, 0x7E, 0xFC, 0xF0, 0xF0, 0xF8, 0x7E, 0x1E, 0x06, 0x02, 0x00, 0xF0,
121:               0xFC, 0xFC, 0x0E, 0x06, 0x06, 0x06, 0x1E, 0xFC, 0xFC, 0xF0, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0xFE,
122:               0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE,
123:               0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFC, 0xFC, 0x0E, 0x06, 0x06, 0x06,
124:               0x1E, 0xFC, 0xFC, 0xF0, 0x00, 0x00, 0x38, 0x7C, 0xFE, 0xF6, 0xE6, 0xE6, 0xEE, 0xDE, 0xDC, 0x98,
125:               0x00, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
126:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x01,
127:               0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
128:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
129:               0x0F, 0x0F, 0x1C, 0x18, 0x18, 0x18, 0x1E, 0x0F, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x0F, 0x0F, 0x1F,
130:               0x18, 0x18, 0x18, 0x1F, 0x0F, 0x0F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F,
131:               0x1F, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x03, 0x0F, 0x0F, 0x1C, 0x18, 0x18, 0x18,
132:               0x1E, 0x0F, 0x0F, 0x03, 0x00, 0x00, 0x06, 0x0E, 0x1E, 0x1C, 0x18, 0x18, 0x19, 0x1F, 0x0F, 0x07,
133:               0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
134:               0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xE0, 0xE1, 0xE1, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,
135:               0xE1, 0xE3, 0xE3, 0xC0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
136:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
137:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
138:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
139:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
140:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
141:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
142:               0x00, 0x00, 0x00, 0x06, 0x0F, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
143:               0x00, 0x00, 0x01, 0x03, 0x03, 0x07, 0x0F, 0x1E, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00*/
144:               0x00, 0x00, 0x00, 0x60, 0x90, 0x98, 0x04, 0x04, 0x18, 0x20, 0x40, 0x80, 0xC0, 0xC0, 0xE0, 0xE0,
145:               0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0x80, 0x40, 0x20, 0x18, 0x04, 0x04, 0x98, 0x90, 0x60,
146:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xF0, 0x80, 0x00, 0x00, 0x80, 0xF0,
147:               0x70, 0x00, 0xC0, 0xE0, 0x70, 0x30, 0x30, 0x70, 0xE0, 0xC0, 0x00, 0xF0, 0xF0, 0x00, 0x00, 0x00,
148:               0x00, 0xF0, 0xF0, 0x00, 0x70, 0x70, 0x00, 0xF0, 0xF0, 0x30, 0x30, 0x30, 0x70, 0xE0, 0xC0, 0x00,
149:               0xF0, 0xF0, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
150:               0x60, 0x90, 0x98, 0x04, 0x04, 0x18, 0x20, 0x40, 0x80, 0xC0, 0xC0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,
151:               0xE0, 0xE0, 0xC0, 0xC0, 0x80, 0x40, 0x20, 0x18, 0x04, 0x04, 0x98, 0x90, 0x60, 0x00, 0x00, 0x00,
152:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xE2, 0xFC, 0xFE, 0xFF, 0x9F, 0x0F, 0x0F, 0x9F, 0xFF,
153:               0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0x0F, 0x0F, 0x9F, 0xFF, 0xFE, 0xFC, 0xE2, 0x01, 0x00, 0x00, 0x00,
154:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x3F, 0x3F, 0x03, 0x01,
155:               0x00, 0x00, 0x0F, 0x1F, 0x38, 0x30, 0x30, 0x38, 0x1F, 0x0F, 0x00, 0x0F, 0x1F, 0x38, 0x30, 0x30,
156:               0x38, 0x1F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x06, 0x06, 0x0E, 0x1F, 0x3B, 0x31, 0x00,
157:               0x3F, 0x3F, 0x33, 0x33, 0x33, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
158:               0x00, 0x00, 0x00, 0x01, 0xE2, 0xFC, 0xFE, 0xFF, 0x9F, 0x0F, 0x0F, 0x9F, 0xFF, 0xFF, 0xFF, 0xFF,
159:               0xFF, 0x9F, 0x0F, 0x0F, 0x9F, 0xFF, 0xFE, 0xFC, 0xE2, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
160:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x43, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
161:               0xE3, 0xF1, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x43, 0x80, 0x00, 0x00, 0x00,
162:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
163:               0xFC, 0xFC, 0x0C, 0x0C, 0x0C, 0x1C, 0xF8, 0xF0, 0x00, 0xFC, 0xFC, 0xCC, 0xCC, 0xCC, 0xCC, 0x0C,
164:               0x00, 0xF0, 0xF8, 0xDC, 0xCC, 0xCC, 0xDC, 0xF8, 0xF0, 0x00, 0xFC, 0xFC, 0x0C, 0x0C, 0x0C, 0x1C,
165:               0xF8, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
166:               0x00, 0x00, 0x00, 0x80, 0x43, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xF1, 0xE3,
167:               0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x43, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
168:               0x00, 0x00, 0x00, 0x06, 0x09, 0x19, 0x20, 0x20, 0x18, 0x04, 0x02, 0x1F, 0x11, 0x11, 0x1F, 0x11,
169:               0x11, 0x1F, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x1F, 0x02, 0x04, 0x18, 0x20, 0x20, 0x19, 0x09, 0x06,
170:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
171:               0x0F, 0x0F, 0x0C, 0x0C, 0x0C, 0x0E, 0x07, 0x03, 0x00, 0x0F, 0x0F, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
172:               0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x0F, 0x0F, 0x0C, 0x0C, 0x0C, 0x0E,
173:               0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
174:               0x06, 0x09, 0x19, 0x20, 0x20, 0x18, 0x04, 0x02, 0x1F, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x1F, 0x11,
175:               0x11, 0x1F, 0x11, 0x11, 0x1F, 0x02, 0x04, 0x18, 0x20, 0x20, 0x19, 0x09, 0x06, 0x00, 0x00, 0x00
176:               };
177:               
178:               const unsigned char arrow_for_ammo [] = {
179:               
180:               };
181:               
182:               const unsigned char health_text [] = {
183:               0x7E, 0x08, 0x08, 0x7E, 0x00, 0x7E, 0x4A, 0x4A, 0x42, 0x00, 0x7C, 0x0A, 0x0A, 0x7C, 0x00, 0x7E,
184:               0x40, 0x40, 0x40, 0x02, 0x02, 0x7E, 0x02, 0x02, 0x00, 0x7E, 0x08, 0x08, 0x7E, 0x00, 0x24, 0x00
185:               };
186:               
187:               
188:               const unsigned char ammo_text [] = {
189:               0x7C, 0x0A, 0x0A, 0x7C, 0x00, 0x7C, 0x02, 0x0E, 0x02, 0x7C, 0x00, 0x7C, 0x02, 0x0E, 0x02, 0x7C,
190:               0x00, 0x3C, 0x42, 0x42, 0x3C, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
191:               };
192:               
193:               
194:               const unsigned char cooldown_text [] = {
195:               0x3C, 0x42, 0x42, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x3C, 0x00, 0x3C, 0x42, 0x42, 0x3C, 0x00, 0x7E,
196:               0x40, 0x40, 0x40, 0x00, 0x7E, 0x42, 0x42, 0x3C, 0x00, 0x3C, 0x42, 0x42, 0x3C, 0x00, 0x3E, 0x40,
197:               0x70, 0x40, 0x3E, 0x00, 0x7E, 0x04, 0x08, 0x7E, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
198:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x4A, 0x52, 0x24, 0x00, 0x7E, 0x4A, 0x4A, 0x42,
199:               0x00, 0x3C, 0x42, 0x42, 0x24, 0x00, 0x24, 0x4A, 0x52, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
200:               };
201:               
202:               const unsigned char loaded_arrow [] = {
203:               0x00, 0x00, 0x00, 0x00, 0x08, 0x18, 0x78, 0xF0, 0xE0, 0xC8, 0x98, 0xB8, 0xF0, 0xE0, 0xC0, 0x80,
204:               0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xBE, 0xAA, 0x94, 0x80, 0xBE, 0xA2, 0xBE, 0x80,
205:               0xBE, 0xA0, 0xA0, 0x82, 0xBE, 0x82, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
206:               0x80, 0x88, 0x98, 0xF8, 0xF0, 0xE0, 0xE0, 0xC0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
207:               0x00, 0x00, 0x00, 0x00, 0x10, 0x18, 0x1E, 0x0F, 0x07, 0x13, 0x19, 0x1D, 0x0F, 0x07, 0x03, 0x01,
208:               0x01, 0x01, 0x01, 0x01, 0x7D, 0x41, 0x41, 0x01, 0x7D, 0x45, 0x7D, 0x01, 0x79, 0x15, 0x79, 0x01,
209:               0x7D, 0x45, 0x39, 0x01, 0x7D, 0x55, 0x45, 0x01, 0x7D, 0x45, 0x39, 0x01, 0x01, 0x01, 0x01, 0x01,
210:               0x01, 0x11, 0x19, 0x1F, 0x0F, 0x07, 0x07, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
211:               };
212:               
213:               /*const unsigned char been_hit_text [] = {
214:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xC0, 0xC0,
215:               0xC0, 0xC0, 0xC0, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xFC,
216:               0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0xFC, 0xFC, 0xFC, 0xFC,
217:               0xFC, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
218:               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x01, 0x01,
219:               0x01, 0x01, 0x01, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x3F,
220:               0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x3F, 0x3F,
221:               0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
222:               };*/
223:               
224:               const unsigned char damaged [] = {
225:               0x00, 0x00, 0x00, 0x00, 0x10, 0x28, 0x48, 0x90, 0x10, 0x0E, 0x02, 0x04, 0x08, 0xE6, 0x22, 0x24,
226:               0xC8, 0x10, 0xC8, 0xA8, 0xA4, 0xC4, 0x02, 0xC2, 0x22, 0xE4, 0x28, 0xC4, 0x02, 0xC2, 0xA4, 0xA4,
227:               0xC8, 0x10, 0xC8, 0x26, 0x22, 0x44, 0x04, 0xE4, 0xA8, 0xA8, 0x28, 0x04, 0xE2, 0x24, 0x28, 0xC8,
228:               0x04, 0x02, 0xE2, 0x04, 0x08, 0x04, 0x04, 0x62, 0x54, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
229:               0x00, 0x00, 0x00, 0x02, 0x05, 0x05, 0x09, 0x08, 0x70, 0x40, 0x20, 0x10, 0x10, 0x27, 0x44, 0x44,
230:               0x23, 0x10, 0x27, 0x20, 0x40, 0x47, 0x20, 0x17, 0x10, 0x08, 0x10, 0x67, 0x40, 0x27, 0x10, 0x20,
231:               0x47, 0x20, 0x13, 0x14, 0x15, 0x23, 0x10, 0x27, 0x24, 0x44, 0x44, 0x20, 0x17, 0x24, 0x44, 0x63,
232:               0x10, 0x10, 0x25, 0x40, 0x40, 0x4C, 0x2A, 0x12, 0x04, 0x08, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x00
233:               };
234:               
235:               
236:               const unsigned char numbers [] = {
237:               0x3C, 0x52, 0x4A, 0x3C, 0x00, 0x00, 0x44, 0x7E, 0x40, 0x00, 0x44, 0x62, 0x52, 0x4C, 0x00, 0x24,
238:               0x42, 0x4A, 0x34, 0x00, 0x0E, 0x08, 0x7E, 0x08, 0x00, 0x2E, 0x4A, 0x4A, 0x32, 0x00, 0x3C, 0x4A,
239:               0x4A, 0x30, 0x00, 0x02, 0x62, 0x1A, 0x06, 0x00, 0x34, 0x4A, 0x4A, 0x34, 0x00, 0x0C, 0x52, 0x52,
240:               0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
241:               };
242:               
243:               
244:               // one prototype needed for order of functions in this file
245:               void Fill_RAM_12832(unsigned char Data);
246:               
247:               //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
248:               //  Initialization
249:               //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
250:               void OLED_init()
251:               {
002316  FA0002     LNK #0x2
252:                   int i;
253:               
254:                   //TRISBbits.TRISB12 = 0; // manual output
255:                   //LATBbits.LATB12 = 0;   // SS pin
256:                   //TRISBbits.TRISB13 = 0; //Set pin 13 to output (D/C)
257:                   //TRISBbits.TRISB14 = 0; // reset pin
258:               
259:                   // set reset pin low
260:                   oled_res = 0;
002318  A9E2CD     BCLR 0x2CD, #7
261:                   // int i;
262:                   for(i = 0; i < 16000; i++) {
00231A  EB0000     CLR W0
00231C  780F00     MOV W0, [W14]
00231E  370002     BRA 0x2324
002322  E80F1E     INC [W14], [W14]
002324  23E7F0     MOV #0x3E7F, W0
002326  78009E     MOV [W14], W1
002328  508F80     SUB W1, W0, [W15]
00232A  34FFFA     BRA LE, 0x2320
263:                       Nop();
002320  000000     NOP
264:                   }
265:               
266:                   IFS0bits.SPI1IF = 0; // Clear the Interrupt Flag
00232C  A94085     BCLR 0x85, #2
267:                   IEC0bits.SPI1IE = 0; // Disable the Interrupt
00232E  A94095     BCLR 0x95, #2
268:               
269:                   // DO NOT SET BOTH OF THESE TO ALL 1'S.  I will find you and I will slap you.
270:                   SPI1CON1bits.PPRE = 0b01;  // primary prescale of 16:1
002330  801211     MOV SPI1CON1, W1
002332  2FFFC0     MOV #0xFFFC, W0
002334  608000     AND W1, W0, W0
002336  A00000     BSET W0, #0
002338  881210     MOV W0, SPI1CON1
271:                   SPI1CON1bits.SPRE = 0b110; // secondary prescale of 2:1
00233A  801211     MOV SPI1CON1, W1
00233C  2FFE30     MOV #0xFFE3, W0
00233E  608000     AND W1, W0, W0
002340  B30180     IOR #0x18, W0
002342  881210     MOV W0, SPI1CON1
272:               
273:                   SPI1CON1bits.DISSCK = 0; //Internal Serial Clock is Enabled
002344  A98243     BCLR 0x243, #4
274:                   SPI1CON1bits.DISSDO = 0; //SDOx pin is controlled by the module
002346  A96243     BCLR 0x243, #3
275:                   SPI1CON1bits.MODE16 = 0; //Communication is byte-wide (8 bits)
002348  A94243     BCLR 0x243, #2
276:                   SPI1CON1bits.SSEN = 0; //?
00234A  A9E242     BCLR SPI1CON1, #7
277:                   SPI1CON1bits.SMP = 0; //Input Data is sampled at the middle of
00234C  A92243     BCLR 0x243, #1
278:                                                                      //data output time
279:                   SPI1CON1bits.CKE = 0; //Serial output data changes on
00234E  A90243     BCLR 0x243, #0
280:                                  //transition from idle clock state to active clock state
281:                   SPI1CON1bits.CKP = 1; //Idle state for clock is a low level;
002350  A8C242     BSET SPI1CON1, #6
282:                                                              //active state is a high level
283:                   SPI1CON1bits.MSTEN = 1; //Master Mode Enabled
002352  A8A242     BSET SPI1CON1, #5
284:                   SPI1STATbits.SPIEN = 1; //Enable SPI Module
002354  A8E241     BSET 0x241, #7
285:               
286:                   //IFS0bits.SPI1IF = 0; // Clear the Interrupt Flag
287:                   //IEC0bits.SPI1IE = 1; // Enable the Interrupt
288:               
289:                   // set reset pin high
290:                   oled_res = 1;
002356  A8E2CD     BSET 0x2CD, #7
291:                   // delay about 40 ms
292:               
293:                   for(i = 0; i < 16000; i++) {
002358  EB0000     CLR W0
00235A  780F00     MOV W0, [W14]
00235C  370002     BRA 0x2362
002360  E80F1E     INC [W14], [W14]
002362  23E7F0     MOV #0x3E7F, W0
002364  78009E     MOV [W14], W1
002366  508F80     SUB W1, W0, [W15]
002368  34FFFA     BRA LE, 0x235E
294:                       Nop();
00235E  000000     NOP
295:                   }
296:               
297:                   Set_Display_On_Off_12832(0x01);		// ---display on
00236A  B3C010     MOV #0x1, W0
00236C  0702A9     RCALL Set_Display_On_Off_12832
298:                   Set_Display_Clock_12832(0x70);		// Set Clock as 160 Frames/Sec
00236E  B3C700     MOV #0x70, W0
002370  0702C4     RCALL Set_Display_Clock_12832
299:                   Set_Multiplex_Ratio_12832(0x1F);		// 1/32 Duty (0x0F~0x3F)
002372  B3C1F0     MOV #0x1F, W0
002374  070285     RCALL Set_Multiplex_Ratio_12832
300:                   Set_Display_Offset_12832(0x00);		// Shift Mapping RAM Counter (0x00~0x3F)
002376  EB4000     CLR.B W0
002378  0702B8     RCALL Set_Display_Offset_12832
301:                   Set_Start_Line_12832(0x00);			// Set Mapping RAM Display Start Line (0x00~0x3F)
00237A  EB4000     CLR.B W0
00237C  070255     RCALL Set_Start_Line_12832
302:                   Set_Master_Config_12832(0x00);		// Disable Embedded DC/DC Converter (0x00/0x01)
00237E  EB4000     CLR.B W0
002380  070296     RCALL Set_Master_Config_12832
303:                   Set_Area_Color_12832(0x05);			// Set Monochrome & Low Power Save Mode
002382  B3C050     MOV #0x5, W0
002384  0702C2     RCALL Set_Area_Color_12832
304:                   Set_Addressing_Mode_12832(0x00);		// Set Page Addressing Mode (0x00/0x01/0x02)
002386  EB4000     CLR.B W0
002388  070231     RCALL Set_Addressing_Mode_12832
305:                   Set_Segment_Remap_12832(0x00);		// Set SEG/Column Mapping (0x00/0x01)
00238A  EB4000     CLR.B W0
00238C  070264     RCALL Set_Segment_Remap_12832
306:                   Set_Common_Remap_12832(0x00);			// Set COM/Row Scan Direction (0x00/0x08)
00238E  EB4000     CLR.B W0
002390  0702A5     RCALL Set_Common_Remap_12832
307:                   Set_Common_Config_12832(0x10);		// Set Alternative Configuration (0x00/0x10)
002392  B3C100     MOV #0x10, W0
002394  0702CA     RCALL Set_Common_Config_12832
308:                   Set_LUT_12832(0x3F,0x3F,0x3F,0x3F);		// Define All Banks Pulse Width as 64 Clocks
002396  B3C3F3     MOV #0x3F, W3
002398  B3C3F2     MOV #0x3F, W2
00239A  B3C3F1     MOV #0x3F, W1
00239C  B3C3F0     MOV #0x3F, W0
00239E  0702E2     RCALL Set_LUT_12832
309:                   Set_Contrast_Control_12832(0xBF);	// Set SEG Output Current
0023A0  B3CBF0     MOV #0xBF, W0
0023A2  070249     RCALL Set_Contrast_Control_12832
310:                   Set_Area_Brightness_12832(0xBF);	// Set Brightness for Area Color Banks
0023A4  B3CBF0     MOV #0xBF, W0
0023A6  07024F     RCALL Set_Area_Brightness_12832
311:                   Set_Precharge_Period_12832(0xD2);		// Set Pre-Charge as 13 Clocks & Discharge as 2 Clock
0023A8  B3CD20     MOV #0xD2, W0
0023AA  0702B7     RCALL Set_Precharge_Period_12832
312:                   Set_VCOMH_12832(0x08);			// ---Set VCOM Deselect Level
0023AC  B3C080     MOV #0x8, W0
0023AE  0702C6     RCALL Set_VCOMH_12832
313:                   Set_Entire_Display_12832(0x00);		// Disable Entire Display On (0x00/0x01)
0023B0  EB4000     CLR.B W0
0023B2  070258     RCALL Set_Entire_Display_12832
314:                   Set_Inverse_Display_12832(0x00);		// Disable Inverse Display On (0x00/0x01)
0023B4  EB4000     CLR.B W0
0023B6  07025D     RCALL Set_Inverse_Display_12832
315:                   Fill_RAM_12832(0x00);				// Clear Screen
0023B8  EB4000     CLR.B W0
0023BA  070004     RCALL Fill_RAM_12832
316:                   Set_Display_On_Off_12832(0x01);		// Display On (0x00/0x01)
0023BC  B3C010     MOV #0x1, W0
0023BE  070280     RCALL Set_Display_On_Off_12832
317:               }
0023C0  FA8000     ULNK
0023C2  060000     RETURN
318:               
319:               
320:               //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
321:               //  Draw Commands
322:               //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
323:               void Fill_RAM_12832(unsigned char Data)
324:               {
0023C4  FA0004     LNK #0x4
0023C6  984720     MOV.B W0, [W14+2]
325:               unsigned char i,j;
326:               
327:                   for(i=0;i<8;i++)
0023C8  EB4000     CLR.B W0
0023CA  784F00     MOV.B W0, [W14]
0023CC  370011     BRA 0x23F0
0023EE  E84F1E     INC.B [W14], [W14]
0023F0  78401E     MOV.B [W14], W0
0023F2  504FE7     SUB.B W0, #0x7, [W15]
0023F4  36FFEC     BRA LEU, 0x23CE
328:                   {
329:                       Set_Start_Page_12832(i);
0023CE  78401E     MOV.B [W14], W0
0023D0  07027E     RCALL Set_Start_Page_12832
330:                       Set_Start_Column_12832(0x00);
0023D2  EB4000     CLR.B W0
0023D4  0701FE     RCALL Set_Start_Column_12832
331:               
332:                       for(j=0;j<132;j++)
0023D6  EB4000     CLR.B W0
0023D8  984710     MOV.B W0, [W14+1]
0023DA  370005     BRA 0x23E6
0023E0  90401E     MOV.B [W14+1], W0
0023E2  E84000     INC.B W0, W0
0023E4  984710     MOV.B W0, [W14+1]
0023E6  90409E     MOV.B [W14+1], W1
0023E8  B3C830     MOV #0x83, W0
0023EA  50CF80     SUB.B W1, W0, [W15]
0023EC  36FFF7     BRA LEU, 0x23DC
333:                       {
334:                           oled_data(Data);
0023DC  90402E     MOV.B [W14+2], W0
0023DE  0701E8     RCALL oled_data
335:                       }
336:                   }
337:               }
0023F6  FA8000     ULNK
0023F8  060000     RETURN
338:               
339:               void Full_Page(const unsigned char* picture)
340:               {
0023FA  FA0004     LNK #0x4
0023FC  980710     MOV W0, [W14+2]
341:                   unsigned char i,j;
342:               
343:                   for(i=0;i<4;i++)
0023FE  EB4000     CLR.B W0
002400  784F00     MOV.B W0, [W14]
002402  370018     BRA 0x2434
002432  E84F1E     INC.B [W14], [W14]
002434  78401E     MOV.B [W14], W0
002436  504FE3     SUB.B W0, #0x3, [W15]
002438  36FFE5     BRA LEU, 0x2404
344:                   {
345:               	Set_Start_Page_12832(i);
002404  78401E     MOV.B [W14], W0
002406  070263     RCALL Set_Start_Page_12832
346:               	Set_Start_Column_12832(0x00);
002408  EB4000     CLR.B W0
00240A  0701E3     RCALL Set_Start_Column_12832
347:               
348:                       for(j=0;j<128;j++)  //128
00240C  EB4000     CLR.B W0
00240E  984710     MOV.B W0, [W14+1]
002410  37000D     BRA 0x242C
002426  90401E     MOV.B [W14+1], W0
002428  E84000     INC.B W0, W0
00242A  984710     MOV.B W0, [W14+1]
00242C  90401E     MOV.B [W14+1], W0
00242E  504FE0     SUB.B W0, #0x0, [W15]
002430  3DFFF0     BRA GE, 0x2412
349:                       {
350:                           oled_data(picture[ j + i*128 ]);
002412  90401E     MOV.B [W14+1], W0
002414  FB8080     ZE W0, W1
002416  78411E     MOV.B [W14], W2
002418  FB8002     ZE W2, W0
00241A  DD0047     SL W0, #7, W0
00241C  408000     ADD W1, W0, W0
00241E  90009E     MOV [W14+2], W1
002420  408000     ADD W1, W0, W0
002422  784010     MOV.B [W0], W0
002424  0701C5     RCALL oled_data
351:                       }
352:                   }
353:               }
00243A  FA8000     ULNK
00243C  060000     RETURN
354:               
355:               void P23_0_64(const unsigned char* picture)
356:               {
00243E  FA0004     LNK #0x4
002440  980710     MOV W0, [W14+2]
357:                   unsigned char i,j;
358:               
359:                   for(i=0;i<2;i++)
002442  EB4000     CLR.B W0
002444  784F00     MOV.B W0, [W14]
002446  37001F     BRA 0x2486
002484  E84F1E     INC.B [W14], [W14]
002486  78401E     MOV.B [W14], W0
002488  504FE1     SUB.B W0, #0x1, [W15]
00248A  36FFDE     BRA LEU, 0x2448
360:                   {
361:               	Set_Start_Page_12832(i+1);
002448  E8401E     INC.B [W14], W0
00244A  070241     RCALL Set_Start_Page_12832
362:               	Set_Start_Column_12832(0x00);
00244C  EB4000     CLR.B W0
00244E  0701C1     RCALL Set_Start_Column_12832
363:               
364:                       for(j=0;j<64;j++)  //0-64
002450  EB4000     CLR.B W0
002452  984710     MOV.B W0, [W14+1]
002454  370013     BRA 0x247C
002476  90401E     MOV.B [W14+1], W0
002478  E84000     INC.B W0, W0
00247A  984710     MOV.B W0, [W14+1]
00247C  90409E     MOV.B [W14+1], W1
00247E  B3C3F0     MOV #0x3F, W0
002480  50CF80     SUB.B W1, W0, [W15]
002482  36FFE9     BRA LEU, 0x2456
365:                       {
366:                           if (picture != 0x00)
002456  90001E     MOV [W14+2], W0
002458  500FE0     SUB W0, #0x0, [W15]
00245A  32000B     BRA Z, 0x2472
367:                               oled_data(picture[j + i*64 ]);
00245C  90401E     MOV.B [W14+1], W0
00245E  FB8080     ZE W0, W1
002460  78411E     MOV.B [W14], W2
002462  FB8002     ZE W2, W0
002464  DD0046     SL W0, #6, W0
002466  408000     ADD W1, W0, W0
002468  90009E     MOV [W14+2], W1
00246A  408000     ADD W1, W0, W0
00246C  784010     MOV.B [W0], W0
00246E  0701A0     RCALL oled_data
002470  370002     BRA 0x2476
368:                           else
369:                               oled_data(0x00);
002472  EB4000     CLR.B W0
002474  07019D     RCALL oled_data
370:                       }
371:                   }
372:               }
00248C  FA8000     ULNK
00248E  060000     RETURN
373:               
374:               void P23_65_128(const unsigned char* picture)
375:               {
002490  FA0004     LNK #0x4
002492  980710     MOV W0, [W14+2]
376:                   unsigned char i,j;
377:               
378:                   for(i=0;i<2;i++)
002494  EB4000     CLR.B W0
002496  784F00     MOV.B W0, [W14]
002498  37001F     BRA 0x24D8
0024D6  E84F1E     INC.B [W14], [W14]
0024D8  78401E     MOV.B [W14], W0
0024DA  504FE1     SUB.B W0, #0x1, [W15]
0024DC  36FFDE     BRA LEU, 0x249A
379:                   {
380:               	Set_Start_Page_12832(i+1);
00249A  E8401E     INC.B [W14], W0
00249C  070218     RCALL Set_Start_Page_12832
381:               	Set_Start_Column_12832(65);
00249E  B3C410     MOV #0x41, W0
0024A0  070198     RCALL Set_Start_Column_12832
382:               
383:                       for(j=0;j<64;j++)  //65-128
0024A2  EB4000     CLR.B W0
0024A4  984710     MOV.B W0, [W14+1]
0024A6  370013     BRA 0x24CE
0024C8  90401E     MOV.B [W14+1], W0
0024CA  E84000     INC.B W0, W0
0024CC  984710     MOV.B W0, [W14+1]
0024CE  90409E     MOV.B [W14+1], W1
0024D0  B3C3F0     MOV #0x3F, W0
0024D2  50CF80     SUB.B W1, W0, [W15]
0024D4  36FFE9     BRA LEU, 0x24A8
384:                       {
385:                           if (picture != 0x00)
0024A8  90001E     MOV [W14+2], W0
0024AA  500FE0     SUB W0, #0x0, [W15]
0024AC  32000B     BRA Z, 0x24C4
386:                               oled_data(picture[j + i*64 ]);
0024AE  90401E     MOV.B [W14+1], W0
0024B0  FB8080     ZE W0, W1
0024B2  78411E     MOV.B [W14], W2
0024B4  FB8002     ZE W2, W0
0024B6  DD0046     SL W0, #6, W0
0024B8  408000     ADD W1, W0, W0
0024BA  90009E     MOV [W14+2], W1
0024BC  408000     ADD W1, W0, W0
0024BE  784010     MOV.B [W0], W0
0024C0  070177     RCALL oled_data
0024C2  370002     BRA 0x24C8
387:                           else
388:                               oled_data(0x00);
0024C4  EB4000     CLR.B W0
0024C6  070174     RCALL oled_data
389:                       }
390:                   }
391:               }
0024DE  FA8000     ULNK
0024E0  060000     RETURN
392:               
393:               void P1_0_31(const unsigned char* picture)
394:               {
0024E2  FA0004     LNK #0x4
0024E4  980710     MOV W0, [W14+2]
395:                   unsigned char j;
396:               
397:                   Set_Start_Page_12832(0);
0024E6  EB4000     CLR.B W0
0024E8  0701F2     RCALL Set_Start_Page_12832
398:                   Set_Start_Column_12832(0);
0024EA  EB4000     CLR.B W0
0024EC  070172     RCALL Set_Start_Column_12832
399:               
400:                   for(j=0;j<31;j++)  // 0-31
0024EE  EB4000     CLR.B W0
0024F0  784F00     MOV.B W0, [W14]
0024F2  370007     BRA 0x2502
002500  E84F1E     INC.B [W14], [W14]
002502  78401E     MOV.B [W14], W0
002504  504FFE     SUB.B W0, #0x1E, [W15]
002506  36FFF6     BRA LEU, 0x24F4
401:                   {
402:                       oled_data(picture[j]);
0024F4  78409E     MOV.B [W14], W1
0024F6  FB8001     ZE W1, W0
0024F8  90009E     MOV [W14+2], W1
0024FA  408000     ADD W1, W0, W0
0024FC  784010     MOV.B [W0], W0
0024FE  070158     RCALL oled_data
403:                   }
404:               
405:               }
002508  FA8000     ULNK
00250A  060000     RETURN
406:               
407:               void P4_0_31(const unsigned char* picture)
408:               {
00250C  FA0004     LNK #0x4
00250E  980710     MOV W0, [W14+2]
409:                   unsigned char j;
410:               
411:                   Set_Start_Page_12832(3);
002510  B3C030     MOV #0x3, W0
002512  0701DD     RCALL Set_Start_Page_12832
412:                   Set_Start_Column_12832(0);
002514  EB4000     CLR.B W0
002516  07015D     RCALL Set_Start_Column_12832
413:               
414:                   for(j=0;j<31;j++)  // 0-31
002518  EB4000     CLR.B W0
00251A  784F00     MOV.B W0, [W14]
00251C  370007     BRA 0x252C
00252A  E84F1E     INC.B [W14], [W14]
00252C  78401E     MOV.B [W14], W0
00252E  504FFE     SUB.B W0, #0x1E, [W15]
002530  36FFF6     BRA LEU, 0x251E
415:                   {
416:                       oled_data(picture[j]);
00251E  78409E     MOV.B [W14], W1
002520  FB8001     ZE W1, W0
002522  90009E     MOV [W14+2], W1
002524  408000     ADD W1, W0, W0
002526  784010     MOV.B [W0], W0
002528  070143     RCALL oled_data
417:                   }
418:               }
002532  FA8000     ULNK
002534  060000     RETURN
419:               
420:               void P4_48_128(const unsigned char* picture)
421:               {
002536  FA0004     LNK #0x4
002538  980710     MOV W0, [W14+2]
422:                   unsigned char j;
423:               
424:                   Set_Start_Page_12832(3);
00253A  B3C030     MOV #0x3, W0
00253C  0701C8     RCALL Set_Start_Page_12832
425:                   Set_Start_Column_12832(48);
00253E  B3C300     MOV #0x30, W0
002540  070148     RCALL Set_Start_Column_12832
426:               
427:                   for(j=0;j<80;j++)  // 48-96
002542  EB4000     CLR.B W0
002544  784F00     MOV.B W0, [W14]
002546  37000D     BRA 0x2562
002560  E84F1E     INC.B [W14], [W14]
002562  B3C4F0     MOV #0x4F, W0
002564  78409E     MOV.B [W14], W1
002566  50CF80     SUB.B W1, W0, [W15]
002568  36FFEF     BRA LEU, 0x2548
428:                   {
429:                       if (picture != 0x00)
002548  90001E     MOV [W14+2], W0
00254A  500FE0     SUB W0, #0x0, [W15]
00254C  320007     BRA Z, 0x255C
430:                           oled_data(picture[j]);
00254E  78409E     MOV.B [W14], W1
002550  FB8001     ZE W1, W0
002552  90009E     MOV [W14+2], W1
002554  408000     ADD W1, W0, W0
002556  784010     MOV.B [W0], W0
002558  07012B     RCALL oled_data
00255A  370002     BRA 0x2560
431:                       else
432:                           oled_data(0x00);
00255C  EB4000     CLR.B W0
00255E  070128     RCALL oled_data
433:                   }
434:               }
00256A  FA8000     ULNK
00256C  060000     RETURN
435:               
436:               //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
437:               //  Logic Functions
438:               //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
439:               
440:               void update_health(int health)
441:               {
00256E  FA0016     LNK #0x16
002570  980F20     MOV W0, [W14+20]
442:                   char number[ITOASIZE] = "";
002572  B80060     MUL.UU W0, #0, W0
002574  980710     MOV W0, [W14+2]
002576  980721     MOV W1, [W14+4]
002578  78000E     MOV W14, W0
00257A  B00060     ADD #0x6, W0
00257C  090005     REPEAT #0x5
00257E  EB1800     CLR [W0++]
002580  EB5800     CLR.B [W0++]
443:                   itoa(number, health, 10);
002582  E8800E     INC2 W14, W0
002584  2000A2     MOV #0xA, W2
002586  9008AE     MOV [W14+20], W1
002588  07EE9F     RCALL _itoa
444:                   uart_chrstr("health at ");
00258A  295320     MOV #0x9532, W0
00258C  070226     RCALL uart_chrstr
445:                   uart_chrstr(number);
00258E  E8800E     INC2 W14, W0
002590  070224     RCALL uart_chrstr
446:                   uart_newline();
002592  070210     RCALL uart_newline
447:               
448:                   unsigned int j;
449:               
450:                   Set_Start_Page_12832(0);
002594  EB4000     CLR.B W0
002596  07019B     RCALL Set_Start_Page_12832
451:                   Set_Start_Column_12832(34);
002598  B3C220     MOV #0x22, W0
00259A  07011B     RCALL Set_Start_Column_12832
452:               
453:                   oled_data(0x7E);
00259C  B3C7E0     MOV #0x7E, W0
00259E  070108     RCALL oled_data
454:                   for(j = 0; j < 50; j++)  //65-128
0025A0  EB0000     CLR W0
0025A2  780F00     MOV W0, [W14]
0025A4  37000D     BRA 0x25C0
0025BE  E80F1E     INC [W14], [W14]
0025C0  200310     MOV #0x31, W0
0025C2  78009E     MOV [W14], W1
0025C4  508F80     SUB W1, W0, [W15]
0025C6  36FFEF     BRA LEU, 0x25A6
455:                   {
456:                       if (j < health/2)
0025A6  9008AE     MOV [W14+20], W1
0025A8  200020     MOV #0x2, W0
0025AA  780100     MOV W0, W2
0025AC  090011     REPEAT #0x11
0025AE  D80082     DIV.SW W1, W2
0025B0  500F9E     SUB W0, [W14], [W15]
0025B2  360003     BRA LEU, 0x25BA
457:                           oled_data(0x7E);
0025B4  B3C7E0     MOV #0x7E, W0
0025B6  0700FC     RCALL oled_data
0025B8  370002     BRA 0x25BE
458:                       else
459:                           oled_data(0x42);
0025BA  B3C420     MOV #0x42, W0
0025BC  0700F9     RCALL oled_data
460:                   }
461:                   oled_data(0x7E);
0025C8  B3C7E0     MOV #0x7E, W0
0025CA  0700F2     RCALL oled_data
462:               }
0025CC  FA8000     ULNK
0025CE  060000     RETURN
463:               
464:               void screen_display(enum SCRN mode)
465:               {
0025D0  FA0002     LNK #0x2
0025D2  780F00     MOV W0, [W14]
466:                   if (mode == SPLASH)
0025D4  78001E     MOV [W14], W0
0025D6  500FE0     SUB W0, #0x0, [W15]
0025D8  3A0003     BRA NZ, 0x25E0
467:                   {
468:                       // lol
469:                       Full_Page(logo);
0025DA  28EE20     MOV #0x8EE2, W0
0025DC  07FF0E     RCALL Full_Page
0025DE  37000F     BRA 0x25FE
470:                   }
471:                   else if (mode == MAIN)
0025E0  78001E     MOV [W14], W0
0025E2  500FE1     SUB W0, #0x1, [W15]
0025E4  3A0007     BRA NZ, 0x25F4
472:                   {
473:                       // clear screen
474:                       Fill_RAM_12832(0x00);
0025E6  EB4000     CLR.B W0
0025E8  07FEED     RCALL Fill_RAM_12832
475:                       // draw all parts of main screen
476:                       P1_0_31(health_text);
0025EA  293620     MOV #0x9362, W0
0025EC  07FF7A     RCALL P1_0_31
477:                       P4_0_31(ammo_text);
0025EE  293820     MOV #0x9382, W0
0025F0  07FF8D     RCALL P4_0_31
0025F2  370005     BRA 0x25FE
478:                   }
479:                   else if (mode == DEAD)
0025F4  78001E     MOV [W14], W0
0025F6  500FE2     SUB W0, #0x2, [W15]
0025F8  3A0002     BRA NZ, 0x25FE
480:                   {
481:                       // dead screen
482:                       Full_Page(dead);
0025FA  291620     MOV #0x9162, W0
0025FC  07FEFE     RCALL Full_Page
483:                   }
484:               }
0025FE  FA8000     ULNK
002600  060000     RETURN
485:               
486:               void update_load(bool loaded)
487:               {
002602  FA0002     LNK #0x2
002604  784F00     MOV.B W0, [W14]
488:                   if (loaded)
002606  78401E     MOV.B [W14], W0
002608  504FE0     SUB.B W0, #0x0, [W15]
00260A  320003     BRA Z, 0x2612
489:                       uart_chrstr("bolt loaded?!");
00260C  2953D0     MOV #0x953D, W0
00260E  0701E5     RCALL uart_chrstr
002610  370002     BRA 0x2616
490:                   else
491:                       uart_chrstr("no bolt loaded...");
002612  2954B0     MOV #0x954B, W0
002614  0701E2     RCALL uart_chrstr
492:                   uart_newline();
002616  0701CE     RCALL uart_newline
493:               
494:                   if (loaded)
002618  78401E     MOV.B [W14], W0
00261A  504FE0     SUB.B W0, #0x0, [W15]
00261C  320003     BRA Z, 0x2624
495:                   {
496:                       // draw loaded arrow
497:                       P23_0_64(loaded_arrow);
00261E  293F20     MOV #0x93F2, W0
002620  07FF0E     RCALL P23_0_64
002622  370002     BRA 0x2628
498:                   } else {
499:                       // clear location
500:                       P23_0_64(0x00);
002624  EB0000     CLR W0
002626  07FF0B     RCALL P23_0_64
501:                   }
502:               }
002628  FA8000     ULNK
00262A  060000     RETURN
503:               
504:               void update_ammo(int amount)
505:               {
00262C  FA001A     LNK #0x1A
00262E  980F40     MOV W0, [W14+24]
506:                   char number[ITOASIZE] = "";
002630  B80060     MUL.UU W0, #0, W0
002632  980730     MOV W0, [W14+6]
002634  980741     MOV W1, [W14+8]
002636  78000E     MOV W14, W0
002638  B000A0     ADD #0xA, W0
00263A  090005     REPEAT #0x5
00263C  EB1800     CLR [W0++]
00263E  EB5800     CLR.B [W0++]
507:                   itoa(number, amount, 10);
002640  470066     ADD W14, #0x6, W0
002642  2000A2     MOV #0xA, W2
002644  9008CE     MOV [W14+24], W1
002646  07EE40     RCALL _itoa
508:                   uart_chrstr("ammo level at ");
002648  2955D0     MOV #0x955D, W0
00264A  0701C7     RCALL uart_chrstr
509:                   uart_chrstr(number);
00264C  470066     ADD W14, #0x6, W0
00264E  0701C5     RCALL uart_chrstr
510:                   uart_newline();
002650  0701B1     RCALL uart_newline
511:               
512:                   unsigned int i, j;
513:               
514:                   Set_Start_Page_12832(3);
002652  B3C030     MOV #0x3, W0
002654  07013C     RCALL Set_Start_Page_12832
515:                   Set_Start_Column_12832(29);
002656  B3C1D0     MOV #0x1D, W0
002658  0700BC     RCALL Set_Start_Column_12832
516:               
517:                   //oled_data(0x7E);
518:                   int digit;
519:                   for(i = 0; i < 4; i++)
00265A  EB0000     CLR W0
00265C  780F00     MOV W0, [W14]
00265E  370011     BRA 0x2682
002680  E80F1E     INC [W14], [W14]
002682  78001E     MOV [W14], W0
002684  500FE3     SUB W0, #0x3, [W15]
002686  36FFEC     BRA LEU, 0x2660
002688  370001     BRA 0x268C
520:                   {
521:                       digit = amount/10;
002660  9008CE     MOV [W14+24], W1
002662  2000A0     MOV #0xA, W0
002664  780100     MOV W0, W2
002666  090011     REPEAT #0x11
002668  D80082     DIV.SW W1, W2
00266A  980720     MOV W0, [W14+4]
522:                       if (digit > 0)
00266C  90002E     MOV [W14+4], W0
00266E  500FE0     SUB W0, #0x0, [W15]
002670  34000C     BRA LE, 0x268A
523:                           oled_data(numbers[i+5*digit]);
002672  90002E     MOV [W14+4], W0
002674  B90065     MUL.SU W0, #5, W0
002676  780000     MOV W0, W0
002678  40001E     ADD W0, [W14], W0
00267A  294F21     MOV #0x94F2, W1
00267C  784061     MOV.B [W1+W0], W0
00267E  070098     RCALL oled_data
524:                       else
525:                           break; //oled_data(0x00); // clear the space
00268A  000000     NOP
526:                   }
527:                   oled_data(0x00); // buffer space
00268C  EB4000     CLR.B W0
00268E  070090     RCALL oled_data
528:                   // now do ones digit
529:                   for(j = 0; j < 4; j++)
002690  EB0000     CLR W0
002692  980710     MOV W0, [W14+2]
002694  370013     BRA 0x26BC
0026B6  90001E     MOV [W14+2], W0
0026B8  E80000     INC W0, W0
0026BA  980710     MOV W0, [W14+2]
0026BC  90001E     MOV [W14+2], W0
0026BE  500FE3     SUB W0, #0x3, [W15]
0026C0  36FFEA     BRA LEU, 0x2696
530:                   {
531:                       digit = amount % 10;
002696  9008CE     MOV [W14+24], W1
002698  2000A0     MOV #0xA, W0
00269A  780100     MOV W0, W2
00269C  090011     REPEAT #0x11
00269E  D80082     DIV.SW W1, W2
0026A0  FD0080     EXCH W0, W1
0026A2  980720     MOV W0, [W14+4]
532:                       oled_data(numbers[j+5*digit]);
0026A4  90002E     MOV [W14+4], W0
0026A6  B90065     MUL.SU W0, #5, W0
0026A8  780000     MOV W0, W0
0026AA  780080     MOV W0, W1
0026AC  90001E     MOV [W14+2], W0
0026AE  408000     ADD W1, W0, W0
0026B0  294F21     MOV #0x94F2, W1
0026B2  784061     MOV.B [W1+W0], W0
0026B4  07007D     RCALL oled_data
533:                   }
534:                   if (amount/10 == 0) // if we didn't place the tens digit, and moved the ones digit forward
0026C2  90084E     MOV [W14+24], W0
0026C4  400069     ADD W0, #0x9, W0
0026C6  500FF2     SUB W0, #0x12, [W15]
0026C8  3E000B     BRA GTU, 0x26E0
535:                   {
536:                       // put blank space after the ones digit
537:                       for(j = 0; j < 4; j++)
0026CA  EB0000     CLR W0
0026CC  980710     MOV W0, [W14+2]
0026CE  370005     BRA 0x26DA
0026D4  90001E     MOV [W14+2], W0
0026D6  E80000     INC W0, W0
0026D8  980710     MOV W0, [W14+2]
0026DA  90001E     MOV [W14+2], W0
0026DC  500FE3     SUB W0, #0x3, [W15]
0026DE  36FFF8     BRA LEU, 0x26D0
538:                       oled_data(0x00);
0026D0  EB4000     CLR.B W0
0026D2  07006E     RCALL oled_data
539:                   }
540:               }
0026E0  FA8000     ULNK
0026E2  060000     RETURN
541:               
542:               void update_hit(bool hit)
543:               {
0026E4  FA0002     LNK #0x2
0026E6  784F00     MOV.B W0, [W14]
544:                   if (hit)
0026E8  78401E     MOV.B [W14], W0
0026EA  504FE0     SUB.B W0, #0x0, [W15]
0026EC  320003     BRA Z, 0x26F4
545:                   {
546:                       // draw hit icon
547:                       P23_65_128(damaged);
0026EE  294720     MOV #0x9472, W0
0026F0  07FECF     RCALL P23_65_128
0026F2  370002     BRA 0x26F8
548:                   }
549:                   else
550:                   {
551:                       // apparently clear?
552:                       P23_65_128(0x00);
0026F4  EB0000     CLR W0
0026F6  07FECC     RCALL P23_65_128
553:                   }
554:               }
0026F8  FA8000     ULNK
0026FA  060000     RETURN
555:               
556:               void cooldown_display(int count) {
0026FC  FA0018     LNK #0x18
0026FE  980F30     MOV W0, [W14+22]
557:                   int i, digit;
558:                   char number[ITOASIZE] = "";
002700  B80060     MUL.UU W0, #0, W0
002702  980720     MOV W0, [W14+4]
002704  980731     MOV W1, [W14+6]
002706  78000E     MOV W14, W0
002708  B00080     ADD #0x8, W0
00270A  090005     REPEAT #0x5
00270C  EB1800     CLR [W0++]
00270E  EB5800     CLR.B [W0++]
559:                   itoa(number, count, 10);
002710  470064     ADD W14, #0x4, W0
002712  2000A2     MOV #0xA, W2
002714  9008BE     MOV [W14+22], W1
002716  07EDD8     RCALL _itoa
560:                   uart_chrstr("cooldown at ");
002718  2956C0     MOV #0x956C, W0
00271A  07015F     RCALL uart_chrstr
561:                   uart_chrstr(number);
00271C  470064     ADD W14, #0x4, W0
00271E  07015D     RCALL uart_chrstr
562:                   uart_newline();
002720  070149     RCALL uart_newline
563:               
564:                   if (count > 0) {
002722  90083E     MOV [W14+22], W0
002724  500FE0     SUB W0, #0x0, [W15]
002726  34001A     BRA LE, 0x275C
565:                       // display cooldown label, and number
566:                       P4_48_128(cooldown_text);
002728  293A20     MOV #0x93A2, W0
00272A  07FF05     RCALL P4_48_128
567:                       Set_Start_Column_12832(96); // after the colon but before "secs"
00272C  B3C600     MOV #0x60, W0
00272E  070051     RCALL Set_Start_Column_12832
568:                       // assuming cooldown is only one digit
569:                       for(i = 0; i < 4; i++)
002730  EB0000     CLR W0
002732  780F00     MOV W0, [W14]
002734  37000F     BRA 0x2754
002752  E80F1E     INC [W14], [W14]
002754  78001E     MOV [W14], W0
002756  500FE3     SUB W0, #0x3, [W15]
002758  34FFEE     BRA LE, 0x2736
00275A  370002     BRA 0x2760
570:                       {
571:                           digit = count % 10;
002736  9008BE     MOV [W14+22], W1
002738  2000A0     MOV #0xA, W0
00273A  780100     MOV W0, W2
00273C  090011     REPEAT #0x11
00273E  D80082     DIV.SW W1, W2
002740  FD0080     EXCH W0, W1
002742  980710     MOV W0, [W14+2]
572:                           oled_data(numbers[i+5*digit]);
002744  90001E     MOV [W14+2], W0
002746  B90065     MUL.SU W0, #5, W0
002748  780000     MOV W0, W0
00274A  40001E     ADD W0, [W14], W0
00274C  294F21     MOV #0x94F2, W1
00274E  784061     MOV.B [W1+W0], W0
002750  07002F     RCALL oled_data
573:                       }
574:               
575:                   } else {
576:                       // clear that portion of the screen
577:                       P4_48_128(0x00);
00275C  EB0000     CLR W0
00275E  07FEEB     RCALL P4_48_128
578:                       //for(i = 48; i < 128; i++)
579:                       //    oled_data(0x00); // finish clearing line
580:                   }
581:               };
002760  FA8000     ULNK
002762  060000     RETURN
582:               
583:               void fire_display(bool firing) {
002764  FA0002     LNK #0x2
002766  784F00     MOV.B W0, [W14]
584:                   if (firing)
002768  78401E     MOV.B [W14], W0
00276A  504FE0     SUB.B W0, #0x0, [W15]
00276C  320003     BRA Z, 0x2774
585:                       uart_chrstr("firing bolt!");
00276E  295790     MOV #0x9579, W0
002770  070134     RCALL uart_chrstr
002772  370002     BRA 0x2778
586:                   else
587:                       uart_chrstr("not firing...");
002774  295860     MOV #0x9586, W0
002776  070131     RCALL uart_chrstr
588:                   uart_newline();
002778  07011D     RCALL uart_newline
589:               
590:                   if (firing) {
00277A  78401E     MOV.B [W14], W0
00277C  504FE0     SUB.B W0, #0x0, [W15]
00277E  320003     BRA Z, 0x2786
591:                       P23_0_64(fire);
002780  290E20     MOV #0x90E2, W0
002782  07FE5D     RCALL P23_0_64
002784  370002     BRA 0x278A
592:                       //Full_Page(fire);
593:                   } else {
594:                       P23_0_64(0x00);
002786  EB0000     CLR W0
002788  07FE5A     RCALL P23_0_64
595:                       //Fill_RAM_12832(0x00);
596:                       // draw all parts of main screen
597:                       //P1_0_31(health_text);
598:                       //P4_0_31(ammo_text);
599:                   }
600:               };
00278A  FA8000     ULNK
00278C  060000     RETURN
601:               
602:               
603:               /*int main(void) {
604:                   
605:               
606:                   while (1) {
607:               
608:                       if (U1STAbits.URXDA == 1) {
609:                           char value = U1RXREG;
610:                           U1TXREG = value;
611:               
612:                           if (value == '0') {
613:                               //
614:                               Fill_RAM_12832(0x00);
615:                           }
616:                           if (value == '1') {
617:                               //
618:                               Full_Page(logo);
619:                           }
620:                           if (value == '2') {
621:                               //
622:                               Full_Page(fire);
623:                           }
624:                           if (value == '3') {
625:                               //
626:                               Full_Page(dead);
627:                           }
628:                           if (value == '4') {
629:                               //
630:                               P23_0_64(loaded_arrow);
631:                           }
632:                           if (value == '5') {
633:                               //
634:                               P23_65_128(been_hit_text);
635:                           }
636:               
637:                           if (value == '6') {
638:                               //
639:                               P23_0_64(hit_or_load_clear);
640:                           }
641:               
642:                           if (value == '7') {
643:                               //
644:                               P23_65_128(hit_or_load_clear);
645:                           }
646:               
647:                           if (value == '8') {
648:                               //
649:                               Health_Bar(25); //50% health
650:                           }
651:               
652:                           if (value == '9') {
653:                               //
654:                               Health_Bar(50);  //100% health
655:                           }
656:               
657:                           if (value == 'a') {
658:                               //
659:                               P1_0_52(health_text);  //health text
660:                           }
661:               
662:               
663:                       }
664:                   };
665:               
666:                   return (EXIT_SUCCESS);
667:               }*/
668:               
669:               
670:               /*void __attribute__((interrupt, no_auto_psv)) _SPI1Interrupt(void) {
671:                   // interrupt for SPI
672:                   // clear receive buffer
673:                   int value = SPI1BUF; // this clears SPIRBF and prevents SPIROV
674:               
675:                   IFS0bits.SPI1IF = 0; // clear interrupt flag
676:               }*/
677:               
---  H:/ecen4013/integration2/integration2.X/main.c  ----------------------------------------------------
1:                 /* 
2:                  * File:   main.c
3:                  * Author: coltmw
4:                  * AKA Colt Wilkens
5:                  *
6:                  * Created on March 5, 2014, 4:06 PM
7:                  */
8:                 
9:                 #include <p24HJ64GP502.h>
10:                #include <pps.h>
11:                
12:                #include <stdio.h>
13:                #include <stdlib.h>
14:                #include <string.h>
15:                
16:                #include "logics.h"
17:                #include "captouch.h"
18:                #include "canbus.h"
19:                
20:                #define MAXCMDLEN 40
21:                
22:                extern char touchdata[TOUCHSIZE+1];
23:                
24:                // global state
25:                typedef enum {
26:                    EMPTY,
27:                    LOADED,
28:                    ARMED
29:                } state_t;
30:                
31:                #define COOLDOWN_TIME 4
32:                #define MAXAMMO       30
33:                #define MAXHEALTH     100
34:                
35:                // global state
36:                state_t firing_state = EMPTY;
37:                int ammo = MAXAMMO;
38:                int health = MAXHEALTH;
39:                int cooldown_secs = 0;
40:                int boltstrength = 0;
41:                struct SFLAGS {
42:                    bool packet_received;  // IR packet received
43:                    bool cooldown_display; // update cooldown display
44:                    // update momentary messages on screen
45:                    bool dmg_display;
46:                    bool fire_display;
47:                };
48:                struct SFLAGS flags;
49:                
50:                
51:                // IR packet info
52:                enum MIRP packet;
53:                // IR parsing variables
54:                volatile unsigned int s_on, s_off, d_on1, d_off1, d_on2, d_off2, stop;
55:                //volatile unsigned int s_on2, s_off2, s_on3, s_off3, s_on4, s_off4; // DEBUG
56:                volatile char rx_state;     /*      0 : Scanning
57:                                             *      1 : Data sampling
58:                                             *      2 : Process
59:                                             *      3 : Error
60:                                             */
61:                
62:                // other functions
63:                void start_cooldown_timer();
64:                void start_dmg_timer();
65:                void start_fire_timer();
66:                
67:                void IO_init();
68:                
69:                // FBS
70:                #pragma config BWRP = WRPROTECT_ON      // Boot Segment Write Protect (Boot segment is write-protected)
71:                #pragma config BSS = NO_FLASH           // Boot Segment Program Flash Code Protection (No Boot program Flash segment)
72:                #pragma config RBS = NO_RAM             // Boot Segment RAM Protection (No Boot RAM)
73:                
74:                // FSS
75:                #pragma config SWRP = WRPROTECT_ON      // Secure Segment Program Write Protect (Secure segment is write-protected)
76:                #pragma config SSS = NO_FLASH           // Secure Segment Program Flash Code Protection (No Secure Segment)
77:                #pragma config RSS = NO_RAM             // Secure Segment Data RAM Protection (No Secure RAM)
78:                
79:                // FGS
80:                #pragma config GWRP = OFF               // General Code Segment Write Protect (User program memory is not write-protected)
81:                #pragma config GSS = OFF                // General Segment Code Protection (User program memory is not code-protected)
82:                
83:                // FOSCSEL
84:                #pragma config FNOSC = FRC  // Oscillator Mode (Internal Fast RC (FRC) with divide by N)
85:                //#pragma config FNOSC = LPRCDIVN  // Oscillator Mode (Internal Fast RC (FRC) with divide by N)
86:                #pragma config IESO = OFF        // Internal External Switch Over Mode
87:                // (Start-up device with FRC, then automatically switch to user-selected oscillator source when ready)
88:                #pragma config FWDTEN = OFF     // turn off watchdog timer because oops.
89:                
90:                #pragma config ALTI2C = OFF
91:                #pragma config JTAGEN = OFF
92:                
93:                #pragma config OSCIOFNC = ON            // OSC2 Pin Function (OSC2 pin has digital I/O function)
94:                
95:                // FOSC= FIN*M/(N1*N2), FCY=FOSC/2
96:                // FOSC= 8M*40(2*2)=80MHz for 8M input clock
97:                
98:                /*
99:                 * The prototype integration code for MAGE Crossbow 2.0
100:                * It uses skeleton functions in logics.h (implemented in logics.c)
101:                * And a UART connection from a computer that emulates inputs.
102:                *
103:                * This is where the magic happens.
104:                */
105:               int main(int argc, char** argv) {
00175C  FA0050     LNK #0x50
00175E  982760     MOV W0, [W14+76]
001760  982771     MOV W1, [W14+78]
106:               
107:                   // first up: clock timing.
108:                   // Internal Fast RC oscillator (default) is FOSC = 7.37 MHz nominal.
109:                   // (see pg 120 of datasheet)
110:                   // DOZE is set to FCY/8 on default, but DOZEN sets it to off.
111:                   // FCY (processor clock) is FOSC/2, so FCY = 3.685 (4 MHz)
112:               
113:                   //PLLFBD = 50;
114:                   // wait for PLL to start up
115:                   // while (OSCCONbits.LOCK != 1) {};
116:               
117:                   // note OSC2 pin was janky IO because of OSCIOFNC bit
118:                   // which might be a config bit
119:                   // pragma config OSCIOFNC = ON // to set OSC2 (RA3) to I/O pin3
120:               
121:                   // next up: UART initialization
122:                   // set all that analog shit to 0
123:                   AD1PCFGL = 0xFFFF;
001762  EB8000     SETM W0
001764  881960     MOV W0, AD1PCFGL
124:               
125:                   RPOR0bits.RP0R = 0b00011 /* U1TX */;    // output pin RP0 for transmit
001766  803601     MOV RPOR0, W1
001768  2FFE00     MOV #0xFFE0, W0
00176A  608000     AND W1, W0, W0
00176C  B30030     IOR #0x3, W0
00176E  883600     MOV W0, RPOR0
126:                   RPINR18bits.U1RXR = 1;                  // input pin RP1 for receive
001770  803521     MOV RPINR18, W1
001772  2FFE00     MOV #0xFFE0, W0
001774  608000     AND W1, W0, W0
001776  A00000     BSET W0, #0
001778  883520     MOV W0, RPINR18
127:               
128:                   // config BRG scaler
129:                   // U1BRG = FCY/(16*baud) - 1
130:                   // U1BRG = 3.685 MHz/(16*9600) - 1 = 23.99 - 1 = 23
131:                   U1BRG = 23;
00177A  200170     MOV #0x17, W0
00177C  881140     MOV W0, U1BRG
132:               
133:                   U1MODEbits.STSEL = 0; // 1 stop bit
00177E  A90220     BCLR U1MODE, #0
134:                   U1MODEbits.PDSEL = 0; // 8 bit, no parity
001780  801101     MOV U1MODE, W1
001782  2FFF90     MOV #0xFFF9, W0
001784  608000     AND W1, W0, W0
001786  881100     MOV W0, U1MODE
135:                   U1MODEbits.ABAUD = 0; // auto-baud off
001788  A9A220     BCLR U1MODE, #5
136:                   U1MODEbits.BRGH = 0;  // not high speed
00178A  A96220     BCLR U1MODE, #3
137:                   U1STAbits.URXISEL = 0; // disable interrupt?
00178C  801111     MOV U1STA, W1
00178E  2FF3F0     MOV #0xFF3F, W0
001790  608000     AND W1, W0, W0
001792  881110     MOV W0, U1STA
138:                   // enable UART
139:                   U1MODEbits.UARTEN = 1;
001794  A8E221     BSET 0x221, #7
140:                   U1STAbits.UTXEN = 1;  // enable transmit
001796  A84223     BSET 0x223, #2
141:               
142:                   /* wait at least 104 ?s (1/9600) before sending first char */
143:                   unsigned int i, j; //??
144:                   for(i = 0; i < 4160; i++)
001798  EB0000     CLR W0
00179A  780F00     MOV W0, [W14]
00179C  370002     BRA 0x17A2
0017A0  E80F1E     INC [W14], [W14]
0017A2  2103F0     MOV #0x103F, W0
0017A4  78009E     MOV [W14], W1
0017A6  508F80     SUB W1, W0, [W15]
0017A8  36FFFA     BRA LEU, 0x179E
145:                   {
146:                    Nop();  // DONT TAKE THIS OUT OR IT FREAKS OUT
00179E  000000     NOP
147:                   }
148:               
149:                   uart_chrstr("\r\nBooting...");
0017AA  295940     MOV #0x9594, W0
0017AC  070916     RCALL uart_chrstr
150:                   uart_newline();
0017AE  070902     RCALL uart_newline
151:                   // magical peripheral inits!
152:                   IO_init();
0017B0  0702CE     RCALL IO_init
153:                   LED_init();
0017B2  070BA3     RCALL LED_init
154:                   uart_chrstr("initializing OLED display...\r\n");
0017B4  295A10     MOV #0x95A1, W0
0017B6  070911     RCALL uart_chrstr
155:                   OLED_init();
0017B8  0705AE     RCALL OLED_init
156:                   screen_display(SPLASH);
0017BA  EB0000     CLR W0
0017BC  070709     RCALL screen_display
157:                   audio_init();
0017BE  070B2E     RCALL audio_init
158:                   for(i = 0; i < 10000; i++)
0017C0  EB0000     CLR W0
0017C2  780F00     MOV W0, [W14]
0017C4  37000C     BRA 0x17DE
0017DC  E80F1E     INC [W14], [W14]
0017DE  2270F0     MOV #0x270F, W0
0017E0  78009E     MOV [W14], W1
0017E2  508F80     SUB W1, W0, [W15]
0017E4  36FFF0     BRA LEU, 0x17C6
159:                   {
160:                       for(j = 0; j < 60; j++)
0017C6  EB0000     CLR W0
0017C8  980710     MOV W0, [W14+2]
0017CA  370004     BRA 0x17D4
0017CE  90001E     MOV [W14+2], W0
0017D0  E80000     INC W0, W0
0017D2  980710     MOV W0, [W14+2]
0017D4  90009E     MOV [W14+2], W1
0017D6  2003B0     MOV #0x3B, W0
0017D8  508F80     SUB W1, W0, [W15]
0017DA  36FFF8     BRA LEU, 0x17CC
161:                       {
162:                           Nop();
0017CC  000000     NOP
163:                       }
164:                   }
165:                   play_sound(6); //AUD_START);
0017E6  200060     MOV #0x6, W0
0017E8  070B72     RCALL play_sound
166:                   // wait a bit... 1 sec?
167:                   for(i = 0; i < 10000; i++)
0017EA  EB0000     CLR W0
0017EC  780F00     MOV W0, [W14]
0017EE  37000C     BRA 0x1808
001806  E80F1E     INC [W14], [W14]
001808  2270F0     MOV #0x270F, W0
00180A  78009E     MOV [W14], W1
00180C  508F80     SUB W1, W0, [W15]
00180E  36FFF0     BRA LEU, 0x17F0
168:                   {
169:                       for(j = 0; j < 60; j++)
0017F0  EB0000     CLR W0
0017F2  980710     MOV W0, [W14+2]
0017F4  370004     BRA 0x17FE
0017F8  90001E     MOV [W14+2], W0
0017FA  E80000     INC W0, W0
0017FC  980710     MOV W0, [W14+2]
0017FE  90009E     MOV [W14+2], W1
001800  2003B0     MOV #0x3B, W0
001802  508F80     SUB W1, W0, [W15]
001804  36FFF8     BRA LEU, 0x17F6
170:                       {
171:                           Nop();
0017F6  000000     NOP
172:                       }
173:                   }
174:                   touch_init();
001810  07043D     RCALL touch_init
175:                   CAN_init();
001812  0709CE     RCALL CAN_init
176:               
177:                   screen_display(MAIN);
001814  200010     MOV #0x1, W0
001816  0706DC     RCALL screen_display
178:                   im_dead(); // for testing CANbus ------------
001818  070A4A     RCALL im_dead
179:                   
180:               
181:                   uart_chrstr("Mk 4 booted.\r\n\r\n");
00181A  295C00     MOV #0x95C0, W0
00181C  0708DE     RCALL uart_chrstr
182:               
183:                   // UI display inits
184:                   update_ammo(ammo);
00181E  8041C0     MOV 0x838, W0
001820  070705     RCALL update_ammo
185:                   update_health(health);
001822  8041D0     MOV 0x83A, W0
001824  0706A4     RCALL update_health
186:                   // initialize state variables
187:                   flags.packet_received = false;
001826  EB4000     CLR.B W0
001828  B7E820     MOV.B WREG, flags
188:                   flags.cooldown_display = false;
00182A  EB4000     CLR.B W0
00182C  B7E821     MOV.B WREG, 0x821
189:                   flags.dmg_display = false;
00182E  EB4000     CLR.B W0
001830  B7E822     MOV.B WREG, 0x822
190:                   flags.fire_display = false;
001832  EB4000     CLR.B W0
001834  B7E823     MOV.B WREG, 0x823
191:               
192:                   // UART variables
193:                   char value;
194:                   char command[MAXCMDLEN] = "";
001836  296070     MOV #0x9607, W0
001838  784090     MOV.B [W0], W1
00183A  984F51     MOV.B W1, [W14+13]
00183C  78000E     MOV W14, W0
00183E  B000E0     ADD #0xE, W0
001840  090026     REPEAT #0x26
001842  EB5800     CLR.B [W0++]
195:                   int charcount = 0;
001844  EB0000     CLR W0
001846  980720     MOV W0, [W14+4]
001848  370001     BRA 0x184C
196:                   
197:                   while (1)
198:                   {
199:                       /*int val = CANrx();
200:                       if (val != -1) {
201:                           uart_chrstr("CANrx!\r\n");
202:                           char num = ecan1MsgBuf[val][4]; // third data byte
203:                           char number[ITOASIZE] = "";
204:                           itoa(number, num, 10);
205:                           uart_chrstr("data byte 3: ");
206:                           uart_chrstr(number);
207:                           uart_newline();
208:                       }*/
209:               
210:                       //CAN_init();
211:                       /*for(i = 0; i < 10000; i++)
212:                       {
213:                           for(j = 0; j < 60; j++)
214:                           {
215:                               Nop();
216:                           }
217:                       }*/
218:                       // check all flags from interrupts
219:                       if (flags.packet_received)
00184C  BFC820     MOV.B flags, WREG
00184E  504FE0     SUB.B W0, #0x0, [W15]
001850  320033     BRA Z, 0x18B8
220:                       {
221:                           flags.packet_received = false;
001852  EB4000     CLR.B W0
001854  B7E820     MOV.B WREG, flags
222:                           // parse packet results
223:                           if (packet == HIT)
001856  804120     MOV packet, W0
001858  500FE1     SUB W0, #0x1, [W15]
00185A  3A000F     BRA NZ, 0x187A
224:                           {
225:                               play_sound(AUD_HIT);
00185C  200030     MOV #0x3, W0
00185E  070B37     RCALL play_sound
226:                               update_hit(true);       // turn on hit icon
001860  B3C010     MOV #0x1, W0
001862  070740     RCALL update_hit
227:                               start_dmg_timer();      // start timer to turn off hit icon
001864  0700EF     RCALL start_dmg_timer
228:                               health -= 1;
001866  8041D0     MOV 0x83A, W0
001868  E90000     DEC W0, W0
00186A  8841D0     MOV W0, 0x83A
229:                               if (health < 0)
00186C  8041D0     MOV 0x83A, W0
00186E  500FE0     SUB W0, #0x0, [W15]
001870  3D0002     BRA GE, 0x1876
230:                                   health = 0;
001872  EB0000     CLR W0
001874  8841D0     MOV W0, 0x83A
231:                               update_health(health);  // update health display
001876  8041D0     MOV 0x83A, W0
001878  07067A     RCALL update_health
232:                           }
233:                           if (packet == HEAL)
00187A  804120     MOV packet, W0
00187C  500FE2     SUB W0, #0x2, [W15]
00187E  3A000B     BRA NZ, 0x1896
234:                           {
235:                               health += 1;
001880  8041D0     MOV 0x83A, W0
001882  E80000     INC W0, W0
001884  8841D0     MOV W0, 0x83A
236:                               if (health > 100)
001886  8041D1     MOV 0x83A, W1
001888  200640     MOV #0x64, W0
00188A  508F80     SUB W1, W0, [W15]
00188C  340002     BRA LE, 0x1892
237:                                   health = 100;
00188E  200640     MOV #0x64, W0
001890  8841D0     MOV W0, 0x83A
238:                               update_health(health);
001892  8041D0     MOV 0x83A, W0
001894  07066C     RCALL update_health
239:                           }
240:                           if (health == 0) // soooo dead
001896  8041D0     MOV 0x83A, W0
001898  500FE0     SUB W0, #0x0, [W15]
00189A  3A000E     BRA NZ, 0x18B8
241:                           {
242:                               screen_display(DEAD);
00189C  200020     MOV #0x2, W0
00189E  070698     RCALL screen_display
243:                               play_sound(AUD_DEAD);
0018A0  200050     MOV #0x5, W0
0018A2  070B15     RCALL play_sound
244:                               bool sent_dead = false;
0018A4  EB4000     CLR.B W0
0018A6  984760     MOV.B W0, [W14+6]
245:                               while (!sent_dead)
0018A8  370002     BRA 0x18AE
0018AE  90406E     MOV.B [W14+6], W0
0018B0  A20400     BTG.B W0, #0
0018B2  504FE0     SUB.B W0, #0x0, [W15]
0018B4  3AFFFA     BRA NZ, 0x18AA
246:                                   sent_dead = im_dead();
0018AA  070A01     RCALL im_dead
0018AC  984760     MOV.B W0, [W14+6]
247:                               // dead, so eat cycles
248:                               while (1) {};
0018B6  37FFFF     BRA 0x18B6
249:                           }
250:                       }
251:                       if (flags.cooldown_display)
0018B8  BFC821     MOV.B 0x821, WREG
0018BA  504FE0     SUB.B W0, #0x0, [W15]
0018BC  320009     BRA Z, 0x18D0
252:                       {
253:                           if (cooldown_secs == COOLDOWN_TIME-1)
0018BE  8041E0     MOV 0x83C, W0
0018C0  500FE3     SUB W0, #0x3, [W15]
0018C2  3A0002     BRA NZ, 0x18C8
254:                               play_sound(AUD_COOLDOWN);
0018C4  200040     MOV #0x4, W0
0018C6  070B03     RCALL play_sound
255:                           flags.cooldown_display = false;
0018C8  EB4000     CLR.B W0
0018CA  B7E821     MOV.B WREG, 0x821
256:                           cooldown_display(cooldown_secs);
0018CC  8041E0     MOV 0x83C, W0
0018CE  070716     RCALL cooldown_display
257:                       }
258:                       if (flags.dmg_display)
0018D0  BFC822     MOV.B 0x822, WREG
0018D2  504FE0     SUB.B W0, #0x0, [W15]
0018D4  320004     BRA Z, 0x18DE
259:                       {
260:                           flags.dmg_display = false;
0018D6  EB4000     CLR.B W0
0018D8  B7E822     MOV.B WREG, 0x822
261:                           update_hit(false);
0018DA  EB4000     CLR.B W0
0018DC  070703     RCALL update_hit
262:                       }
263:                       if (flags.fire_display)
0018DE  BFC823     MOV.B 0x823, WREG
0018E0  504FE0     SUB.B W0, #0x0, [W15]
0018E2  320004     BRA Z, 0x18EC
264:                       {
265:                           flags.fire_display = false;
0018E4  EB4000     CLR.B W0
0018E6  B7E823     MOV.B WREG, 0x823
266:                           fire_display(false);
0018E8  EB4000     CLR.B W0
0018EA  07073C     RCALL fire_display
267:                       }
268:                       
269:                       touchtype event = check_touch();
0018EC  200360     MOV #0x36, W0
0018EE  40000E     ADD W0, W14, W0
0018F0  070485     RCALL check_touch
270:                       if (event.istap) {
0018F2  90706E     MOV.B [W14+54], W0
0018F4  504FE0     SUB.B W0, #0x0, [W15]
0018F6  320030     BRA Z, 0x1958
271:                           uart_chrstr("TAP EVENT");
0018F8  295D10     MOV #0x95D1, W0
0018FA  07086F     RCALL uart_chrstr
272:                           im_dead(); // testing CAN bus
0018FC  0709D8     RCALL im_dead
273:                           uart_newline();
0018FE  07085A     RCALL uart_newline
274:                           // do tap stuff
275:                           if (firing_state == EMPTY && cooldown_secs == 0) {
001900  8041B0     MOV 0x836, W0
001902  500FE0     SUB W0, #0x0, [W15]
001904  3A000D     BRA NZ, 0x1920
001906  8041E0     MOV 0x83C, W0
001908  500FE0     SUB W0, #0x0, [W15]
00190A  3A000A     BRA NZ, 0x1920
276:                               if (ammo > 0) {
00190C  8041C0     MOV 0x838, W0
00190E  500FE0     SUB W0, #0x0, [W15]
001910  340023     BRA LE, 0x1958
00191E  37001C     BRA 0x1958
277:                                   update_load(true);
001912  B3C010     MOV #0x1, W0
001914  070676     RCALL update_load
278:                                   play_sound(AUD_LOAD);
001916  200020     MOV #0x2, W0
001918  070ADA     RCALL play_sound
279:                                   firing_state = LOADED;
00191A  200010     MOV #0x1, W0
00191C  8841B0     MOV W0, 0x836
280:                               }
281:                               else
282:                               {
283:                                   // out of ammo stuff
284:                               }
285:                           }
286:                           else if (firing_state == ARMED) {
001920  8041B0     MOV 0x836, W0
001922  500FE2     SUB W0, #0x2, [W15]
001924  3A0019     BRA NZ, 0x1958
287:                               update_load(false);
001926  EB4000     CLR.B W0
001928  07066C     RCALL update_load
288:                               fire_display(true);
00192A  B3C010     MOV #0x1, W0
00192C  07071B     RCALL fire_display
289:                               start_fire_timer();
00192E  070091     RCALL start_fire_timer
290:                               play_sound(1);//AUD_FIRE);
001930  200010     MOV #0x1, W0
001932  070ACD     RCALL play_sound
291:                               shoot_packet(boltstrength);
001934  8041F0     MOV 0x83E, W0
001936  070912     RCALL shoot_packet
292:                               update_led_bar(0);
001938  EB0000     CLR W0
00193A  070AE4     RCALL update_led_bar
293:                               firing_state = EMPTY;
00193C  EB0000     CLR W0
00193E  8841B0     MOV W0, 0x836
294:                               ammo -= 1;
001940  8041C0     MOV 0x838, W0
001942  E90000     DEC W0, W0
001944  8841C0     MOV W0, 0x838
295:                               update_ammo(ammo);
001946  8041C0     MOV 0x838, W0
001948  070671     RCALL update_ammo
296:                               uart_chrstr("after firing complete\r\n");
00194A  295DB0     MOV #0x95DB, W0
00194C  070846     RCALL uart_chrstr
297:                               cooldown_secs = COOLDOWN_TIME;
00194E  200040     MOV #0x4, W0
001950  8841E0     MOV W0, 0x83C
298:                               cooldown_display(cooldown_secs);
001952  8041E0     MOV 0x83C, W0
001954  0706D3     RCALL cooldown_display
299:                               start_cooldown_timer();
001956  07006F     RCALL start_cooldown_timer
300:                           }
301:                       }
302:                       if (event.isswipe) {
001958  90707E     MOV.B [W14+55], W0
00195A  504FE0     SUB.B W0, #0x0, [W15]
00195C  32002F     BRA Z, 0x19BC
303:                           uart_chrstr("SWIPE EVENT, str = ");
00195E  295F30     MOV #0x95F3, W0
001960  07083C     RCALL uart_chrstr
304:                           char number[ITOASIZE] = "";
001962  B80060     MUL.UU W0, #0, W0
001964  981F50     MOV W0, [W14+58]
001966  981F61     MOV W1, [W14+60]
001968  78008E     MOV W14, W1
00196A  B003E1     ADD #0x3E, W1
00196C  090005     REPEAT #0x5
00196E  EB1880     CLR [W1++]
001970  EB5880     CLR.B [W1++]
305:                           uart_chrstr(itoa(number, event.swipestrength, 10));
001972  9018CE     MOV [W14+56], W1
001974  2003A0     MOV #0x3A, W0
001976  40000E     ADD W0, W14, W0
001978  2000A2     MOV #0xA, W2
00197A  07F4A6     RCALL _itoa
00197C  07082E     RCALL uart_chrstr
306:                           uart_newline();
00197E  07081A     RCALL uart_newline
307:                           // do swipe stuff
308:                           if (firing_state == LOADED || firing_state == ARMED) { // ARMED for re-set
001980  8041B0     MOV 0x836, W0
001982  500FE1     SUB W0, #0x1, [W15]
001984  320003     BRA Z, 0x198C
001986  8041B0     MOV 0x836, W0
001988  500FE2     SUB W0, #0x2, [W15]
00198A  3A0018     BRA NZ, 0x19BC
309:                               boltstrength = event.swipestrength;
00198C  90184E     MOV [W14+56], W0
00198E  8841F0     MOV W0, 0x83E
310:                               int bar_bits = 0;
001990  EB0000     CLR W0
001992  980740     MOV W0, [W14+8]
311:                               int b = 0;
001994  EB0000     CLR W0
001996  980750     MOV W0, [W14+10]
312:                               for(b = 0; b < boltstrength; b++) {
001998  EB0000     CLR W0
00199A  980750     MOV W0, [W14+10]
00199C  370007     BRA 0x19AC
0019A6  90005E     MOV [W14+10], W0
0019A8  E80000     INC W0, W0
0019AA  980750     MOV W0, [W14+10]
0019AC  8041F0     MOV 0x83E, W0
0019AE  9000DE     MOV [W14+10], W1
0019B0  508F80     SUB W1, W0, [W15]
0019B2  35FFF5     BRA LT, 0x199E
313:                                   // bitshift to form output
314:                                   bar_bits = (bar_bits << 1) + 1;
00199E  90004E     MOV [W14+8], W0
0019A0  400000     ADD W0, W0, W0
0019A2  E80000     INC W0, W0
0019A4  980740     MOV W0, [W14+8]
315:                               }
316:                               update_led_bar(bar_bits);
0019B4  90004E     MOV [W14+8], W0
0019B6  070AA6     RCALL update_led_bar
317:                               firing_state = ARMED;
0019B8  200020     MOV #0x2, W0
0019BA  8841B0     MOV W0, 0x836
318:                           }
319:                       }
320:               
321:               
322:                       // ------------------ UART HANDLING -----------------
323:                       
324:                       // what does this do
325:                       if (U1STAbits.FERR == 1) {
0019BC  801110     MOV U1STA, W0
0019BE  600064     AND W0, #0x4, W0
0019C0  500FE0     SUB W0, #0x0, [W15]
0019C2  320001     BRA Z, 0x19C6
326:                           continue;
0019C4  370037     BRA 0x1A34
327:                       }
328:                       // clear overrun bit
329:                       if (U1STAbits.OERR == 1) {
0019C6  801110     MOV U1STA, W0
0019C8  600062     AND W0, #0x2, W0
0019CA  500FE0     SUB W0, #0x0, [W15]
0019CC  320002     BRA Z, 0x19D2
330:                           U1STAbits.OERR = 0;
0019CE  A92222     BCLR U1STA, #1
331:                           continue;
0019D0  370031     BRA 0x1A34
332:                       }
333:                       if (U1STAbits.URXDA == 1) {
0019D2  801110     MOV U1STA, W0
0019D4  600061     AND W0, #0x1, W0
0019D6  500FE0     SUB W0, #0x0, [W15]
0019D8  32FF38     BRA Z, 0x184A
334:                           // grab input, process if enter was pressed
335:                           value = U1RXREG;
0019DA  801130     MOV U1RXREG, W0
0019DC  984F40     MOV.B W0, [W14+12]
336:                           if (value == '\r')
0019DE  90484E     MOV.B [W14+12], W0
0019E0  504FED     SUB.B W0, #0xD, [W15]
0019E2  3A0010     BRA NZ, 0x1A04
337:                           {
338:                               if (charcount < MAXCMDLEN)
0019E4  9000AE     MOV [W14+4], W1
0019E6  200270     MOV #0x27, W0
0019E8  508F80     SUB W1, W0, [W15]
0019EA  3C0006     BRA GT, 0x19F8
339:                                   command[charcount] = 0; // try to null-term for safety
0019EC  4700ED     ADD W14, #0xD, W1
0019EE  90002E     MOV [W14+4], W0
0019F0  408080     ADD W1, W0, W1
0019F2  EB4000     CLR.B W0
0019F4  784880     MOV.B W0, [W1]
0019F6  370002     BRA 0x19FC
340:                               else
341:                                   command[MAXCMDLEN] = 0; // chop off last char for null.
0019F8  EB4000     CLR.B W0
0019FA  987750     MOV.B W0, [W14+53]
342:                               charcount = 0;
0019FC  EB0000     CLR W0
0019FE  980720     MOV W0, [W14+4]
343:                               uart_newline();
001A00  0707D9     RCALL uart_newline
344:                               // check command
345:                               /*if (strcmp(command, "toggle") == 0) {
346:                                   // toggle LED
347:                                   uart_chrstr("toggling LED");
348:                                   uart_newline();
349:                                   if (LATAbits.LATA4== 0)
350:                                       LATAbits.LATA4 = 1;
351:                                   else
352:                                       LATAbits.LATA4 = 0;
353:                               }
354:                               if (strncmp(command, "touch ", sizeof("touch ")-1) == 0) {
355:                                   // strip rest and put into touchdata
356:                                   strcpy(touchdata, command+sizeof("touch ")-1);
357:                                   uart_chrstr("grabbed: '");
358:                                   uart_chrstr(touchdata);
359:                                   uart_chrstr("'.");
360:                                   uart_newline();               
361:                               }*/
362:                           } else {
363:                               // throw into command buffer, echo output
364:                               if (charcount < MAXCMDLEN) {
001A04  9000AE     MOV [W14+4], W1
001A06  200270     MOV #0x27, W0
001A08  508F80     SUB W1, W0, [W15]
001A0A  3C0010     BRA GT, 0x1A2C
365:                                   if (value == 127) { // ascii backspace (technically DEL)
001A0C  9048CE     MOV.B [W14+12], W1
001A0E  B3C7F0     MOV #0x7F, W0
001A10  50CF80     SUB.B W1, W0, [W15]
001A12  3A0004     BRA NZ, 0x1A1C
366:                                       charcount -= 1;
001A14  90002E     MOV [W14+4], W0
001A16  E90000     DEC W0, W0
001A18  980720     MOV W0, [W14+4]
001A1A  370008     BRA 0x1A2C
367:                                   } else {
368:                                       command[charcount] = value;
001A1C  4700ED     ADD W14, #0xD, W1
001A1E  90002E     MOV [W14+4], W0
001A20  408000     ADD W1, W0, W0
001A22  9048CE     MOV.B [W14+12], W1
001A24  784801     MOV.B W1, [W0]
369:                                       charcount += 1;
001A26  90002E     MOV [W14+4], W0
001A28  E80000     INC W0, W0
001A2A  980720     MOV W0, [W14+4]
370:                                   }
371:                               }
372:                               U1TXREG = value;
001A2C  90484E     MOV.B [W14+12], W0
001A2E  FB0000     SE W0, W0
001A30  881120     MOV W0, U1TXREG
373:                           }
374:                       }
375:                       
376:                   }
00184A  000000     NOP
001A02  37FF24     BRA 0x184C
001A32  37FF0C     BRA 0x184C
001A34  37FF0B     BRA 0x184C
377:               
378:                   return (EXIT_SUCCESS);
379:               }
380:               
381:               void start_cooldown_timer()
382:               {
001A36  FA0000     LNK #0x0
383:                   TMR1 = 0;               // reset timer count
001A38  EB0000     CLR W0
001A3A  880800     MOV W0, TMR1
384:                   IEC0bits.T1IE = 1;      // enable timer1 interrupt
001A3C  A86094     BSET IEC0, #3
385:                   T1CONbits.TON = 1;      // start timer
001A3E  A8E105     BSET 0x105, #7
386:               }
001A40  FA8000     ULNK
001A42  060000     RETURN
387:               
388:               void start_dmg_timer()
389:               {
001A44  FA0000     LNK #0x0
390:                   TMR2 = 0;               // reset timer count
001A46  EB0000     CLR W0
001A48  880830     MOV W0, TMR2
391:                   IEC0bits.T2IE = 1;      // enable timer2 interrupt
001A4A  A8E094     BSET IEC0, #7
392:                   T2CONbits.TON = 1;      // start timer
001A4C  A8E111     BSET 0x111, #7
393:               }
001A4E  FA8000     ULNK
001A50  060000     RETURN
394:               
395:               void start_fire_timer()
396:               {
001A52  FA0000     LNK #0x0
397:                   TMR3 = 0;               // reset timer count
001A54  EB0000     CLR W0
001A56  880850     MOV W0, TMR3
398:                   IEC0bits.T3IE = 1;      // enable timer3 interrupt
001A58  A80095     BSET 0x95, #0
399:                   T3CONbits.TON = 1;      // start timer
001A5A  A8E113     BSET 0x113, #7
400:               }
001A5C  FA8000     ULNK
001A5E  060000     RETURN
401:               
402:               void __attribute__((__interrupt__, no_auto_psv)) _T1Interrupt(void)
403:               {
001A60  781F80     MOV W0, [W15++]
001A62  FA0000     LNK #0x0
404:                   // ISR goes here
405:                   if (cooldown_secs > 0)
001A64  8041E0     MOV 0x83C, W0
001A66  500FE0     SUB W0, #0x0, [W15]
001A68  340006     BRA LE, 0x1A76
406:                   {
407:                       cooldown_secs -= 1;
001A6A  8041E0     MOV 0x83C, W0
001A6C  E90000     DEC W0, W0
001A6E  8841E0     MOV W0, 0x83C
408:                       flags.cooldown_display = true;
001A70  B3C010     MOV #0x1, W0
001A72  B7E821     MOV.B WREG, 0x821
001A74  370002     BRA 0x1A7A
409:                   } else {
410:                       T1CONbits.TON = 0;      // turn off timer
001A76  A9E105     BCLR 0x105, #7
411:                       IEC0bits.T1IE = 0;      // disable timer1 interrupt
001A78  A96094     BCLR IEC0, #3
412:                   }
413:               
414:                   IFS0bits.T1IF = 0; // clear Timer1 interrupt flag
001A7A  A96084     BCLR IFS0, #3
415:               }
001A7C  FA8000     ULNK
001A7E  78004F     MOV [--W15], W0
001A80  064000     RETFIE
416:               
417:               // these two are one-time interrupts, so turn off timer right after
418:               void __attribute__((__interrupt__, no_auto_psv)) _T2Interrupt(void)
419:               {
001A82  781F80     MOV W0, [W15++]
001A84  FA0000     LNK #0x0
420:                   flags.dmg_display = true;
001A86  B3C010     MOV #0x1, W0
001A88  B7E822     MOV.B WREG, 0x822
421:                   T2CONbits.TON = 0;      // turn off timer
001A8A  A9E111     BCLR 0x111, #7
422:                   IEC0bits.T2IE = 0;      // disable timer interrupt
001A8C  A9E094     BCLR IEC0, #7
423:                   IFS0bits.T2IF = 0;      // clear Timer2 interrupt flag
001A8E  A9E084     BCLR IFS0, #7
424:               }
001A90  FA8000     ULNK
001A92  78004F     MOV [--W15], W0
001A94  064000     RETFIE
425:               
426:               void __attribute__((__interrupt__, no_auto_psv)) _T3Interrupt(void)
427:               {
001A96  781F80     MOV W0, [W15++]
001A98  FA0000     LNK #0x0
428:                   flags.fire_display = true;
001A9A  B3C010     MOV #0x1, W0
001A9C  B7E823     MOV.B WREG, 0x823
429:                   T3CONbits.TON = 0;      // turn off timer
001A9E  A9E113     BCLR 0x113, #7
430:                   IEC0bits.T3IE = 0;      // disable timer interrupt
001AA0  A90095     BCLR 0x95, #0
431:                   IFS0bits.T3IF = 0;      // clear Timer2 interrupt flag
001AA2  A90085     BCLR 0x85, #0
432:               }
001AA4  FA8000     ULNK
001AA6  78004F     MOV [--W15], W0
001AA8  064000     RETFIE
433:               
434:               enum MIRP packet;
435:               volatile unsigned int s_on, s_off, d_on1, d_off1, d_on2, d_off2, stop;
436:               //volatile unsigned int s_on2, s_off2, s_on3, s_off3, s_on4, s_off4; // DEBUG
437:               volatile char rx_state;     /*      0 : Scanning
438:                                            *      1 : Data sampling
439:                                            *      2 : Process
440:                                            *      3 : Error
441:                                            */
442:               
443:               void __attribute__((__interrupt__, no_auto_psv)) _INT1Interrupt(void)
444:               {
001AAA  F80036     PUSH RCOUNT
001AAC  BE9F80     MOV.D W0, [W15++]
001AAE  BE9F82     MOV.D W2, [W15++]
001AB0  BE9F84     MOV.D W4, [W15++]
001AB2  BE9F86     MOV.D W6, [W15++]
001AB4  FA0012     LNK #0x12
445:                   // ISR goes here
446:                   packet = ERROR;
001AB6  EB0000     CLR W0
001AB8  884120     MOV W0, packet
447:                   rx_state = 0;
001ABA  EB4000     CLR.B W0
001ABC  B7E834     MOV.B WREG, rx_state
448:                   s_on = 0;
001ABE  EB0000     CLR W0
001AC0  884130     MOV W0, s_on
449:                   s_off = 0;
001AC2  EB0000     CLR W0
001AC4  884140     MOV W0, s_off
450:                   d_on1 = 0;
001AC6  EB0000     CLR W0
001AC8  884150     MOV W0, d_on1
451:                   d_off1 = 0;
001ACA  EB0000     CLR W0
001ACC  884160     MOV W0, d_off1
452:                   d_on2 = 0;
001ACE  EB0000     CLR W0
001AD0  884170     MOV W0, d_on2
453:                   d_off2 = 0;
001AD2  EB0000     CLR W0
001AD4  884180     MOV W0, d_off2
454:                   stop = 0;
001AD6  EB0000     CLR W0
001AD8  884190     MOV W0, stop
455:               
456:                   // DEBUG CODE
457:                   /*s_on2 = 0;
458:                   s_off2 = 0;
459:                   s_on3 = 0;
460:                   s_off3 = 0;
461:                   s_on4 = 0;
462:                   s_off4 = 0;
463:                   d_on1 = 0;
464:                   d_off1 = 0;
465:                   d_on2 = 0;
466:                   d_off2 = 0;
467:                   stop = 0;
468:               
469:                   while (ir_rec==0) {
470:                       s_on = s_on + 1;
471:                   }
472:                   while (ir_rec==1) {
473:                       s_off = s_off + 1;
474:                   }
475:               
476:                   while (ir_rec==0) {
477:                       s_on2 = s_on2 + 1;
478:                   }
479:                   while (ir_rec==1) {
480:                       s_off2 = s_off2 + 1;
481:                   }
482:               
483:                   while (ir_rec==0) {
484:                       s_on3 = s_on3 + 1;
485:                   }
486:                   while (ir_rec==1) {
487:                       s_off3 = s_off3 + 1;
488:                   }
489:               
490:                   while (ir_rec==0) {
491:                       s_on4 = s_on4 + 1;
492:                   }
493:                   while (ir_rec==1) {
494:                       s_off4 = s_off4 + 1;
495:                   }
496:               
497:                   char number[ITOASIZE] = "";
498:                   sprintf(number,"%d",s_on);
499:                   uart_chrstr("s_on: ");
500:                   uart_chrstr(number);
501:                   uart_newline();
502:                   char number2[ITOASIZE] = "";
503:                   sprintf(number2,"%d",s_off);
504:                   uart_chrstr("s_off: ");
505:                   uart_chrstr(number2);
506:                   uart_newline();
507:               
508:                   number[ITOASIZE] = "";
509:                   sprintf(number,"%d",s_on2);
510:                   uart_chrstr("s_on2: ");
511:                   uart_chrstr(number);
512:                   uart_newline();
513:                   number2[ITOASIZE] = "";
514:                   sprintf(number2,"%d",s_off2);
515:                   uart_chrstr("s_off2: ");
516:                   uart_chrstr(number2);
517:                   uart_newline();
518:               
519:                   number[ITOASIZE] = "";
520:                   sprintf(number,"%d",s_on3);
521:                   uart_chrstr("s_on3: ");
522:                   uart_chrstr(number);
523:                   uart_newline();
524:                   number2[ITOASIZE] = "";
525:                   sprintf(number2,"%d",s_off3);
526:                   uart_chrstr("s_off3: ");
527:                   uart_chrstr(number2);
528:                   uart_newline();
529:               
530:                   number[ITOASIZE] = "";
531:                   sprintf(number,"%d",s_on4);
532:                   //itoa(number, s_off, 10);
533:                   uart_chrstr("s_on4: ");
534:                   uart_chrstr(number);
535:                   uart_newline();
536:                   number2[ITOASIZE] = "";
537:                   sprintf(number2,"%d",s_off4);
538:                   //itoa(number, s_off, 10);
539:                   uart_chrstr("s_off4: ");
540:                   uart_chrstr(number2);
541:                   uart_newline();*/
542:               
543:                   /*** SCANNING ***/
544:                   if (rx_state == 0) {
001ADA  BFC834     MOV.B rx_state, WREG
001ADC  504FE0     SUB.B W0, #0x0, [W15]
001ADE  3A0025     BRA NZ, 0x1B2A
545:                       //uart_chrstr("rx:0 scanning\r\n");
546:                       while (ir_rx==0) {
001AE0  370003     BRA 0x1AE8
001AE8  801651     MOV PORTB, W1
001AEA  200200     MOV #0x20, W0
001AEC  608000     AND W1, W0, W0
001AEE  500FE0     SUB W0, #0x0, [W15]
001AF0  32FFF8     BRA Z, 0x1AE2
547:                           s_on = s_on + 1;
001AE2  804130     MOV s_on, W0
001AE4  E80000     INC W0, W0
001AE6  884130     MOV W0, s_on
548:                           //if (s_on > )
549:                       }
550:                       while (ir_rx==1) {
001AF2  370007     BRA 0x1B02
001B02  801651     MOV PORTB, W1
001B04  200200     MOV #0x20, W0
001B06  608000     AND W1, W0, W0
001B08  500FE0     SUB W0, #0x0, [W15]
001B0A  3AFFF4     BRA NZ, 0x1AF4
001B0C  370001     BRA 0x1B10
551:                           s_off = s_off + 1;
001AF4  804140     MOV s_off, W0
001AF6  E80000     INC W0, W0
001AF8  884140     MOV W0, s_off
552:                           if (s_off > 1500) break;
001AFA  804141     MOV s_off, W1
001AFC  205DC0     MOV #0x5DC, W0
001AFE  508F80     SUB W1, W0, [W15]
001B00  3E0006     BRA GTU, 0x1B0E
001B0E  000000     NOP
553:                       }
554:                       if(s_off > MIRP_START_OFF_MAX || s_off < MIRP_START_OFF_MIN)
001B10  804141     MOV s_off, W1
001B12  202DA0     MOV #0x2DA, W0
001B14  508F80     SUB W1, W0, [W15]
001B16  3E0004     BRA GTU, 0x1B20
001B18  804141     MOV s_off, W1
001B1A  202BB0     MOV #0x2BB, W0
001B1C  508F80     SUB W1, W0, [W15]
001B1E  3E0003     BRA GTU, 0x1B26
555:                       {
556:                           rx_state = 3;
001B20  B3C030     MOV #0x3, W0
001B22  B7E834     MOV.B WREG, rx_state
001B24  370002     BRA 0x1B2A
557:                           /*char number[ITOASIZE] = "";
558:                           sprintf(number,"%d",s_on);
559:                           uart_chrstr("s_on: ");
560:                           uart_chrstr(number);
561:                           uart_newline();
562:                           char number2[ITOASIZE] = "";
563:                           sprintf(number2,"%d",s_off);
564:                           uart_chrstr("s_off: ");
565:                           uart_chrstr(number2);
566:                           uart_newline();*/
567:                       }
568:                       else
569:                           rx_state = 1;
001B26  B3C010     MOV #0x1, W0
001B28  B7E834     MOV.B WREG, rx_state
570:                   }
571:               
572:                   /*** FRAME ERROR ***/
573:                   if(rx_state == 3) {
001B2A  BFC834     MOV.B rx_state, WREG
001B2C  504FE3     SUB.B W0, #0x3, [W15]
001B2E  3A0006     BRA NZ, 0x1B3C
574:                       rx_state = 0;
001B30  EB4000     CLR.B W0
001B32  B7E834     MOV.B WREG, rx_state
575:               
576:                       s_on = 0;
001B34  EB0000     CLR W0
001B36  884130     MOV W0, s_on
577:                       s_off = 0;
001B38  EB0000     CLR W0
001B3A  884140     MOV W0, s_off
578:                   }
579:               
580:                   /*** DATA SAMPLING ***/
581:                   if(rx_state == 1) {
001B3C  BFC834     MOV.B rx_state, WREG
001B3E  504FE1     SUB.B W0, #0x1, [W15]
001B40  3A003B     BRA NZ, 0x1BB8
582:                       // Data
583:                       while (ir_rx==0) {
001B42  370003     BRA 0x1B4A
001B4A  801651     MOV PORTB, W1
001B4C  200200     MOV #0x20, W0
001B4E  608000     AND W1, W0, W0
001B50  500FE0     SUB W0, #0x0, [W15]
001B52  32FFF8     BRA Z, 0x1B44
584:                           d_on1 = d_on1 + 1;
001B44  804150     MOV d_on1, W0
001B46  E80000     INC W0, W0
001B48  884150     MOV W0, d_on1
585:                       }
586:                       while (ir_rx==1) {
001B54  370009     BRA 0x1B68
001B68  801651     MOV PORTB, W1
001B6A  200200     MOV #0x20, W0
001B6C  608000     AND W1, W0, W0
001B6E  500FE0     SUB W0, #0x0, [W15]
001B70  3AFFF2     BRA NZ, 0x1B56
587:                           d_off1 = d_off1 + 1;
001B56  804160     MOV d_off1, W0
001B58  E80000     INC W0, W0
001B5A  884160     MOV W0, d_off1
588:                           if (d_off1 > 1500) break;
001B5C  804161     MOV d_off1, W1
001B5E  205DC0     MOV #0x5DC, W0
001B60  508F80     SUB W1, W0, [W15]
001B62  360002     BRA LEU, 0x1B68
001B64  000000     NOP
589:                       }
590:               
591:                       // Redundant Data
592:                       while (ir_rx==0) {
001B66  370009     BRA 0x1B7A
001B72  370003     BRA 0x1B7A
001B7A  801651     MOV PORTB, W1
001B7C  200200     MOV #0x20, W0
001B7E  608000     AND W1, W0, W0
001B80  500FE0     SUB W0, #0x0, [W15]
001B82  32FFF8     BRA Z, 0x1B74
593:                           d_on2 = d_on2 + 1;
001B74  804170     MOV d_on2, W0
001B76  E80000     INC W0, W0
001B78  884170     MOV W0, d_on2
594:                       }
595:                       while (ir_rx==1) {
001B84  370009     BRA 0x1B98
001B98  801651     MOV PORTB, W1
001B9A  200200     MOV #0x20, W0
001B9C  608000     AND W1, W0, W0
001B9E  500FE0     SUB W0, #0x0, [W15]
001BA0  3AFFF2     BRA NZ, 0x1B86
596:                           d_off2 = d_off2 + 1;
001B86  804180     MOV d_off2, W0
001B88  E80000     INC W0, W0
001B8A  884180     MOV W0, d_off2
597:                           if (d_off2 > 1500) break;
001B8C  804181     MOV d_off2, W1
001B8E  205DC0     MOV #0x5DC, W0
001B90  508F80     SUB W1, W0, [W15]
001B92  360002     BRA LEU, 0x1B98
001B94  000000     NOP
598:                       }
599:                       // Stop signal
600:                       while (ir_rx==0) {
001B96  370009     BRA 0x1BAA
001BA2  370003     BRA 0x1BAA
001BAA  801651     MOV PORTB, W1
001BAC  200200     MOV #0x20, W0
001BAE  608000     AND W1, W0, W0
001BB0  500FE0     SUB W0, #0x0, [W15]
001BB2  32FFF8     BRA Z, 0x1BA4
601:                           stop = stop + 1;
001BA4  804190     MOV stop, W0
001BA6  E80000     INC W0, W0
001BA8  884190     MOV W0, stop
602:                       }
603:                       rx_state = 2;
001BB4  B3C020     MOV #0x2, W0
001BB6  B7E834     MOV.B WREG, rx_state
604:                   }
605:               
606:               
607:                   if(rx_state == 2)
001BB8  BFC834     MOV.B rx_state, WREG
001BBA  504FE2     SUB.B W0, #0x2, [W15]
001BBC  3A00B6     BRA NZ, 0x1D2A
608:                   {
609:                       char number[ITOASIZE] = "";
001BBE  B80060     MUL.UU W0, #0, W0
001BC0  BE8F00     MOV.D W0, [W14]
001BC2  78000E     MOV W14, W0
001BC4  B00040     ADD #0x4, W0
001BC6  090005     REPEAT #0x5
001BC8  EB1800     CLR [W0++]
001BCA  EB5800     CLR.B [W0++]
610:                       sprintf(number,"%d",d_on1);
001BCC  804150     MOV d_on1, W0
001BCE  781F80     MOV W0, [W15++]
001BD0  2962F0     MOV #0x962F, W0
001BD2  781F80     MOV W0, [W15++]
001BD4  78000E     MOV W14, W0
001BD6  07F387     RCALL __sprintf_cdnopuxX
001BD8  5787E4     SUB W15, #0x4, W15
611:                       uart_chrstr("d_on1: ");
001BDA  296320     MOV #0x9632, W0
001BDC  0706FE     RCALL uart_chrstr
612:                       uart_chrstr(number);
001BDE  78000E     MOV W14, W0
001BE0  0706FC     RCALL uart_chrstr
613:                       uart_newline();
001BE2  0706E8     RCALL uart_newline
614:                       sprintf(number,"%d",d_on2);
001BE4  804170     MOV d_on2, W0
001BE6  781F80     MOV W0, [W15++]
001BE8  2962F0     MOV #0x962F, W0
001BEA  781F80     MOV W0, [W15++]
001BEC  78000E     MOV W14, W0
001BEE  07F37B     RCALL __sprintf_cdnopuxX
001BF0  5787E4     SUB W15, #0x4, W15
615:                       uart_chrstr("d_on2: ");
001BF2  2963A0     MOV #0x963A, W0
001BF4  0706F2     RCALL uart_chrstr
616:                       uart_chrstr(number);
001BF6  78000E     MOV W14, W0
001BF8  0706F0     RCALL uart_chrstr
617:                       uart_newline();
001BFA  0706DC     RCALL uart_newline
618:                       if(s_on > MIRP_START + MIRP_TOLERANCE || s_on < MIRP_START - MIRP_TOLERANCE)
001BFC  804131     MOV s_on, W1
001BFE  200690     MOV #0x69, W0
001C00  508F80     SUB W1, W0, [W15]
001C02  3E0004     BRA GTU, 0x1C0C
001C04  804131     MOV s_on, W1
001C06  2004A0     MOV #0x4A, W0
001C08  508F80     SUB W1, W0, [W15]
001C0A  3E0002     BRA GTU, 0x1C10
619:                       {
620:                           rx_state = 0;
001C0C  EB4000     CLR.B W0
001C0E  B7E834     MOV.B WREG, rx_state
621:                       }
622:                       if(rx_state != 0)
001C10  BFC834     MOV.B rx_state, WREG
001C12  504FE0     SUB.B W0, #0x0, [W15]
001C14  320076     BRA Z, 0x1D02
623:                       {
624:                           if(d_on1 > MIRP_D1 - MIRP_TOLERANCE && d_on1 < MIRP_D1 + MIRP_TOLERANCE &&
001C16  804151     MOV d_on1, W1
001C18  200990     MOV #0x99, W0
001C1A  508F80     SUB W1, W0, [W15]
001C1C  36000F     BRA LEU, 0x1C3C
001C1E  804151     MOV d_on1, W1
001C20  200B60     MOV #0xB6, W0
001C22  508F80     SUB W1, W0, [W15]
001C24  3E000B     BRA GTU, 0x1C3C
001C28  200990     MOV #0x99, W0
001C2A  508F80     SUB W1, W0, [W15]
001C2C  360007     BRA LEU, 0x1C3C
625:                              d_on2 > MIRP_D1 - MIRP_TOLERANCE && d_on2 < MIRP_D1 + MIRP_TOLERANCE)
001C26  804171     MOV d_on2, W1
001C2E  804171     MOV d_on2, W1
001C30  200B60     MOV #0xB6, W0
001C32  508F80     SUB W1, W0, [W15]
001C34  3E0003     BRA GTU, 0x1C3C
626:                           {
627:                               //return HIT;
628:                               packet = HIT;
001C36  200010     MOV #0x1, W0
001C38  884120     MOV W0, packet
001C3A  370063     BRA 0x1D02
629:                           }
630:                           else if(d_on1 > MIRP_D2 - MIRP_TOLERANCE && d_on1 < MIRP_D2 + MIRP_TOLERANCE &&
001C3C  804151     MOV d_on1, W1
001C3E  200DF0     MOV #0xDF, W0
001C40  508F80     SUB W1, W0, [W15]
001C42  36000F     BRA LEU, 0x1C62
001C44  804151     MOV d_on1, W1
001C46  200FC0     MOV #0xFC, W0
001C48  508F80     SUB W1, W0, [W15]
001C4A  3E000B     BRA GTU, 0x1C62
001C4E  200DF0     MOV #0xDF, W0
001C50  508F80     SUB W1, W0, [W15]
001C52  360007     BRA LEU, 0x1C62
631:                              d_on2 > MIRP_D2 - MIRP_TOLERANCE && d_on2 < MIRP_D2 + MIRP_TOLERANCE)
001C4C  804171     MOV d_on2, W1
001C54  804171     MOV d_on2, W1
001C56  200FC0     MOV #0xFC, W0
001C58  508F80     SUB W1, W0, [W15]
001C5A  3E0003     BRA GTU, 0x1C62
632:                           {
633:                               //return HEAL;
634:                               packet = HEAL;
001C5C  200020     MOV #0x2, W0
001C5E  884120     MOV W0, packet
001C60  370050     BRA 0x1D02
635:                           }
636:                           else if(d_on1 > MIRP_D3 - MIRP_TOLERANCE && d_on1 < MIRP_D3 + MIRP_TOLERANCE &&
001C62  804151     MOV d_on1, W1
001C64  201490     MOV #0x149, W0
001C66  508F80     SUB W1, W0, [W15]
001C68  36000F     BRA LEU, 0x1C88
001C6A  804151     MOV d_on1, W1
001C6C  201660     MOV #0x166, W0
001C6E  508F80     SUB W1, W0, [W15]
001C70  3E000B     BRA GTU, 0x1C88
001C74  201490     MOV #0x149, W0
001C76  508F80     SUB W1, W0, [W15]
001C78  360007     BRA LEU, 0x1C88
637:                              d_on2 > MIRP_D3 - MIRP_TOLERANCE && d_on2 < MIRP_D3 + MIRP_TOLERANCE)
001C72  804171     MOV d_on2, W1
001C7A  804171     MOV d_on2, W1
001C7C  201660     MOV #0x166, W0
001C7E  508F80     SUB W1, W0, [W15]
001C80  3E0003     BRA GTU, 0x1C88
638:                           {
639:                               //Third Packet
640:                               packet = THIRD;
001C82  200030     MOV #0x3, W0
001C84  884120     MOV W0, packet
001C86  37003D     BRA 0x1D02
641:                           }
642:                           else if(d_on1 > MIRP_D4 - MIRP_TOLERANCE && d_on1 < MIRP_D4 + MIRP_TOLERANCE &&
001C88  804151     MOV d_on1, W1
001C8A  2019F0     MOV #0x19F, W0
001C8C  508F80     SUB W1, W0, [W15]
001C8E  36000F     BRA LEU, 0x1CAE
001C90  804151     MOV d_on1, W1
001C92  201BC0     MOV #0x1BC, W0
001C94  508F80     SUB W1, W0, [W15]
001C96  3E000B     BRA GTU, 0x1CAE
001C9A  2019F0     MOV #0x19F, W0
001C9C  508F80     SUB W1, W0, [W15]
001C9E  360007     BRA LEU, 0x1CAE
643:                              d_on2 > MIRP_D4 - MIRP_TOLERANCE && d_on2 < MIRP_D4 + MIRP_TOLERANCE)
001C98  804171     MOV d_on2, W1
001CA0  804171     MOV d_on2, W1
001CA2  201BC0     MOV #0x1BC, W0
001CA4  508F80     SUB W1, W0, [W15]
001CA6  3E0003     BRA GTU, 0x1CAE
644:                           {
645:                               //Fourth Packet
646:                               packet = FOURTH;
001CA8  200040     MOV #0x4, W0
001CAA  884120     MOV W0, packet
001CAC  37002A     BRA 0x1D02
647:                           }
648:                           else if(d_on1 > MIRP_D5 - MIRP_TOLERANCE && d_on1 < MIRP_D5 + MIRP_TOLERANCE &&
001CAE  804151     MOV d_on1, W1
001CB0  201F50     MOV #0x1F5, W0
001CB2  508F80     SUB W1, W0, [W15]
001CB4  36000F     BRA LEU, 0x1CD4
001CB6  804151     MOV d_on1, W1
001CB8  202120     MOV #0x212, W0
001CBA  508F80     SUB W1, W0, [W15]
001CBC  3E000B     BRA GTU, 0x1CD4
001CC0  201F50     MOV #0x1F5, W0
001CC2  508F80     SUB W1, W0, [W15]
001CC4  360007     BRA LEU, 0x1CD4
649:                              d_on2 > MIRP_D5 - MIRP_TOLERANCE && d_on2 < MIRP_D5 + MIRP_TOLERANCE)
001CBE  804171     MOV d_on2, W1
001CC6  804171     MOV d_on2, W1
001CC8  202120     MOV #0x212, W0
001CCA  508F80     SUB W1, W0, [W15]
001CCC  3E0003     BRA GTU, 0x1CD4
650:                           {
651:                               //Fifth Packet
652:                               packet = FIFTH;
001CCE  200050     MOV #0x5, W0
001CD0  884120     MOV W0, packet
001CD2  370017     BRA 0x1D02
653:                           }
654:                           else if(d_on1 > MIRP_D6 - MIRP_TOLERANCE && d_on1 < MIRP_D6 + MIRP_TOLERANCE &&
001CD4  804151     MOV d_on1, W1
001CD6  2024B0     MOV #0x24B, W0
001CD8  508F80     SUB W1, W0, [W15]
001CDA  36000F     BRA LEU, 0x1CFA
001CDC  804151     MOV d_on1, W1
001CDE  202680     MOV #0x268, W0
001CE0  508F80     SUB W1, W0, [W15]
001CE2  3E000B     BRA GTU, 0x1CFA
001CE6  2024B0     MOV #0x24B, W0
001CE8  508F80     SUB W1, W0, [W15]
001CEA  360007     BRA LEU, 0x1CFA
655:                              d_on2 > MIRP_D6 - MIRP_TOLERANCE && d_on2 < MIRP_D6 + MIRP_TOLERANCE)
001CE4  804171     MOV d_on2, W1
001CEC  804171     MOV d_on2, W1
001CEE  202680     MOV #0x268, W0
001CF0  508F80     SUB W1, W0, [W15]
001CF2  3E0003     BRA GTU, 0x1CFA
656:                           {
657:                               //Sixth Packet
658:                               packet = SIXTH;
001CF4  200060     MOV #0x6, W0
001CF6  884120     MOV W0, packet
001CF8  370004     BRA 0x1D02
659:                           }
660:                           else
661:                           {
662:                               uart_chrstr("error in packet\r\n");
001CFA  296420     MOV #0x9642, W0
001CFC  07066E     RCALL uart_chrstr
663:                               //return ERROR; //Error Packet
664:                               packet = ERROR;
001CFE  EB0000     CLR W0
001D00  884120     MOV W0, packet
665:                           }
666:                       }
667:               
668:                       s_on = 0;
001D02  EB0000     CLR W0
001D04  884130     MOV W0, s_on
669:                       s_off = 0;
001D06  EB0000     CLR W0
001D08  884140     MOV W0, s_off
670:                       s_on = 0;
001D0A  EB0000     CLR W0
001D0C  884130     MOV W0, s_on
671:                       s_off = 0;
001D0E  EB0000     CLR W0
001D10  884140     MOV W0, s_off
672:                       d_on1 = 0;
001D12  EB0000     CLR W0
001D14  884150     MOV W0, d_on1
673:                       d_off1 = 0;
001D16  EB0000     CLR W0
001D18  884160     MOV W0, d_off1
674:                       d_on2 = 0;
001D1A  EB0000     CLR W0
001D1C  884170     MOV W0, d_on2
675:                       d_off2 = 0;
001D1E  EB0000     CLR W0
001D20  884180     MOV W0, d_off2
676:                       stop = 0;
001D22  EB0000     CLR W0
001D24  884190     MOV W0, stop
677:               
678:                       rx_state = 0;
001D26  EB4000     CLR.B W0
001D28  B7E834     MOV.B WREG, rx_state
679:                   }
680:               
681:                   // raise packet flag to parse in main loop
682:                   // should not be done in interrupt, because if the interrupt was called
683:                   // in a draw function, the health bar's draw function could change
684:                   // drawing addresses... causing stuff to be drawn in the wrong spot
685:                   // when the interrupt returns
686:                   flags.packet_received = true;
001D2A  B3C010     MOV #0x1, W0
001D2C  B7E820     MOV.B WREG, flags
687:               
688:                   IFS1bits.INT1IF = 0; // clear external interrupt flag
001D2E  A98086     BCLR IFS1, #4
689:               }
001D30  FA8000     ULNK
001D32  BE034F     MOV.D [--W15], W6
001D34  BE024F     MOV.D [--W15], W4
001D36  BE014F     MOV.D [--W15], W2
001D38  BE004F     MOV.D [--W15], W0
001D3A  F90036     POP RCOUNT
001D3C  064000     RETFIE
690:               
691:               void __attribute__((__interrupt__, no_auto_psv)) _INT0Interrupt(void)
692:               {
001D3E  FA0000     LNK #0x0
693:                   // ISR goes here
694:                   // IRQ from cap touch chip
695:                   //check_touch();
696:                   //uart_chrstr("touch interrupt.\r\n");
697:               
698:                   // call touch event
699:                   /*touchtype event = check_touch();
700:                   if (event.istap) {
701:                       uart_chrstr("TAP EVENT");
702:                       uart_newline();
703:                       // do tap stuff
704:                       if (firing_state == EMPTY && cooldown_secs == 0) {
705:                           if (ammo > 0) {
706:                           update_load(true);
707:                           play_sound(1);
708:                           firing_state = LOADED;
709:                           }
710:                           else
711:                           {
712:                               // out of ammo stuff
713:                           }
714:                       }
715:                       else if (firing_state == ARMED) {
716:                           fire_display(true);
717:                           play_sound(2);
718:                           shoot_packet(boltstrength);
719:                           firing_state = EMPTY;
720:                           ammo -= 1;
721:                           update_ammo(ammo);
722:                           uart_chrstr("after firing complete\r\n");
723:                           fire_display(false);
724:                           cooldown_secs = COOLDOWN_TIME;
725:                           cooldown_display(cooldown_secs);
726:                           start_cooldown_timer();
727:               
728:                       }
729:               
730:                   }
731:                   if (event.isswipe) {
732:                       uart_chrstr("SWIPE EVENT, str = ");
733:                       char number[ITOASIZE] = "";
734:                       uart_chrstr(itoa(number, event.swipestrength, 10));
735:                       uart_newline();
736:                       // do swipe stuff
737:                       if (firing_state == LOADED || firing_state == ARMED) { // ARMED for re-set 
738:                           boltstrength = event.swipestrength;
739:                           int bar_bits = 0;
740:                           int b = 0;
741:                           for(b = 0; b < boltstrength; b++) {
742:                               // bitshift to form output
743:                               bar_bits = (bar_bits << 1) + 1;
744:                           }
745:                           update_led_bar(bar_bits);
746:                           firing_state = ARMED;
747:                       }
748:                   }*/
749:                   
750:                   IFS0bits.INT0IF = 0; // clear external interrupt flag
001D40  A90084     BCLR IFS0, #0
751:               }
001D42  FA8000     ULNK
001D44  064000     RETFIE
752:               
753:               void __attribute__((__interrupt__, no_auto_psv)) _DMA0Interrupt(void)
754:               {
001D46  FA0000     LNK #0x0
755:                   IFS0bits.DMA0IF = 0;  //Clear the DMA0 Interrupt Flag
001D48  A98084     BCLR IFS0, #4
756:               }
001D4A  FA8000     ULNK
001D4C  064000     RETFIE
757:               
758:               void IO_init()
759:               {
001D4E  FA0000     LNK #0x0
760:                   uart_chrstr("initializing all I/O pins...\r\n");
001D50  296540     MOV #0x9654, W0
001D52  070643     RCALL uart_chrstr
761:                   // init all TRIS bits and remappable bits
762:                   tris_led_data = 0; // bit-banged SPI
001D54  A922C0     BCLR TRISA, #1
763:                   tris_led_clk  = 0; // ^
001D56  A902C0     BCLR TRISA, #0
764:                   //tris_led_ss   = 0; // now tied to 3.3V
765:                   tris_ir_rx    = 1; // probably overridden by INT1, but oh well.
001D58  A8A2C8     BSET TRISB, #5
766:                   tris_ir_tx    = 0; // bit-banged 56kHz MIRP packets
001D5A  A982C8     BCLR TRISB, #4
767:                   //tris_ir_data  = 0; // bit-banged SPI for IR tx power levels
768:                   //tris_ir_clk   = 0; // ^
769:                   tris_oled_d_c = 0; // data/command toggle for OLED SPI
001D5C  A9C2C9     BCLR 0x2C9, #6
770:                   tris_oled_res = 0; // reset line for OLED
001D5E  A9E2C9     BCLR 0x2C9, #7
771:                   tris_aud_clk  = 0;
001D60  A942C8     BCLR TRISB, #2
772:                   tris_aud_data = 0;
001D62  A962C8     BCLR TRISB, #3
773:                   tris_aud_res  = 0;
001D64  A942C0     BCLR TRISA, #2
774:               
775:               
776:                   // one line, map pin for external interrupt
777:                   RPINR0bits.INT1R = 5;     // input pin RP5 for IR input
001D66  803401     MOV RPINR0, W1
001D68  2E0FF0     MOV #0xE0FF, W0
001D6A  608080     AND W1, W0, W1
001D6C  205000     MOV #0x500, W0
001D6E  708000     IOR W1, W0, W0
001D70  883400     MOV W0, RPINR0
778:                   // INT0 is for captouch IRQ, static at pin RP7
779:               
780:                   // remappable pins for SPI (to OLED)
781:                   RPOR6bits.RP12R = 0x0007; //Set pin RP12 to SDO1
001D72  803661     MOV RPOR6, W1
001D74  2FFE00     MOV #0xFFE0, W0
001D76  608000     AND W1, W0, W0
001D78  B30070     IOR #0x7, W0
001D7A  883660     MOV W0, RPOR6
782:                   RPOR6bits.RP13R = 0x0008; //Set pin RP13 to SCK1
001D7C  803661     MOV RPOR6, W1
001D7E  2E0FF0     MOV #0xE0FF, W0
001D80  608080     AND W1, W0, W1
001D82  208000     MOV #0x800, W0
001D84  708000     IOR W1, W0, W0
001D86  883660     MOV W0, RPOR6
783:               
784:                   // remappable pins for CANbus
785:                   RPOR5bits.RP11R = 0b10000 /* C1TX */;   // output pin RP11 for transmit
001D88  803651     MOV RPOR5, W1
001D8A  2E0FF0     MOV #0xE0FF, W0
001D8C  608080     AND W1, W0, W1
001D8E  210000     MOV #0x1000, W0
001D90  708000     IOR W1, W0, W0
001D92  883650     MOV W0, RPOR5
786:                   RPINR26bits.C1RXR = 10;                 // input pin RP10 for receive
001D94  8035A1     MOV RPINR26, W1
001D96  2FFE00     MOV #0xFFE0, W0
001D98  608000     AND W1, W0, W0
001D9A  B300A0     IOR #0xA, W0
001D9C  8835A0     MOV W0, RPINR26
787:                   
788:                   // set timer interrupt for cooldown
789:                   // approx 1 second
790:                   T1CONbits.TON = 0;      // turn off during setup
001D9E  A9E105     BCLR 0x105, #7
791:                   T1CONbits.TCS = 0;      // internal instruction clock source
001DA0  A92104     BCLR T1CON, #1
792:                   T1CONbits.TGATE = 0;    // disable gated timer
001DA2  A9C104     BCLR T1CON, #6
793:                   T1CONbits.TCKPS = 0b11; // select 1:256 prescaler
001DA4  800821     MOV T1CON, W1
001DA6  200300     MOV #0x30, W0
001DA8  708000     IOR W1, W0, W0
001DAA  880820     MOV W0, T1CON
794:                   PR1 = 15625;            // period value (256*15625 = 4 MHz)
001DAC  23D090     MOV #0x3D09, W0
001DAE  880810     MOV W0, PR1
795:                   IPC0bits.T1IP = 0x02;   // timer 1 interrupt priority level
001DB0  800521     MOV IPC0, W1
001DB2  28FFF0     MOV #0x8FFF, W0
001DB4  608080     AND W1, W0, W1
001DB6  220000     MOV #0x2000, W0
001DB8  708000     IOR W1, W0, W0
001DBA  880520     MOV W0, IPC0
796:                   IFS0bits.T1IF = 0;      // clear timer1 interrupt flag
001DBC  A96084     BCLR IFS0, #3
797:                   // call start_cooldown_timer() to start timer
798:                   // automatically turns off when cooldown count is 0
799:                   //IEC0bits.T1IE = 1;      // enable timer1 interrupt
800:                   //T1CONbits.TON = 1;      // start timer
801:               
802:                   // set timer interrupt for "damage" flashing on screen
803:                   T2CONbits.TON = 0;      // turn off during setup
001DBE  A9E111     BCLR 0x111, #7
804:                   T2CONbits.T32 = 0;      // turn off 32 bit timer mode
001DC0  A96110     BCLR T2CON, #3
805:                   T2CONbits.TCS = 0;      // internal instruction clock source
001DC2  A92110     BCLR T2CON, #1
806:                   T2CONbits.TGATE = 0;    // disable gated timer
001DC4  A9C110     BCLR T2CON, #6
807:                   T2CONbits.TCKPS = 0b11; // select 1:256 prescaler
001DC6  800881     MOV T2CON, W1
001DC8  200300     MOV #0x30, W0
001DCA  708000     IOR W1, W0, W0
001DCC  880880     MOV W0, T2CON
808:                   PR2 = 8636; //4318;             // period value (256*4318 = 1105405 -> ~300 ms)
001DCE  221BC0     MOV #0x21BC, W0
001DD0  880860     MOV W0, PR2
809:                   IPC1bits.T2IP = 0x01;   // timer 2 interrupt priority level
001DD2  800531     MOV IPC1, W1
001DD4  28FFF0     MOV #0x8FFF, W0
001DD6  608080     AND W1, W0, W1
001DD8  210000     MOV #0x1000, W0
001DDA  708000     IOR W1, W0, W0
001DDC  880530     MOV W0, IPC1
810:                   IFS0bits.T2IF = 0;      // clear timer2 interrupt flag
001DDE  A9E084     BCLR IFS0, #7
811:               
812:                   // set timer interrupt for "fire" flashing on screen
813:                   T3CONbits.TON = 0;      // turn off during setup
001DE0  A9E113     BCLR 0x113, #7
814:                   T3CONbits.TCS = 0;      // internal instruction clock source
001DE2  A92112     BCLR T3CON, #1
815:                   T3CONbits.TGATE = 0;    // disable gated timer
001DE4  A9C112     BCLR T3CON, #6
816:                   T3CONbits.TCKPS = 0b11; // select 1:256 prescaler
001DE6  800891     MOV T3CON, W1
001DE8  200300     MOV #0x30, W0
001DEA  708000     IOR W1, W0, W0
001DEC  880890     MOV W0, T3CON
817:                   PR3 = 17272; //4318;             // period value (256*4318 = 1105405 -> ~300 ms)
001DEE  243780     MOV #0x4378, W0
001DF0  880870     MOV W0, PR3
818:                   IPC2bits.T3IP = 0x01;   // timer 3 interrupt priority level
001DF2  800541     MOV IPC2, W1
001DF4  2FFF80     MOV #0xFFF8, W0
001DF6  608000     AND W1, W0, W0
001DF8  A00000     BSET W0, #0
001DFA  880540     MOV W0, IPC2
819:                   IFS0bits.T3IF = 0;      // clear timer3 interrupt flag
001DFC  A90085     BCLR 0x85, #0
820:               
821:               
822:                   // set external interrupt for IR input (use ext1 because ext0 is not remappable)
823:                   INTCON2bits.INT1EP = 1; // edge polarity, interrupt on negative edge
001DFE  A82082     BSET INTCON2, #1
824:                   IPC5bits.INT1IP = 0x04; // IR input interrupt priority level
001E00  800571     MOV IPC5, W1
001E02  2FFF80     MOV #0xFFF8, W0
001E04  608000     AND W1, W0, W0
001E06  A02000     BSET W0, #2
001E08  880570     MOV W0, IPC5
825:                   IFS1bits.INT1IF = 0;    // clear interrupt flag
001E0A  A98086     BCLR IFS1, #4
826:                   IEC1bits.INT1IE = 1;    // enable external interrupt
001E0C  A88096     BSET IEC1, #4
827:               
828:                   // external interrupt for captouch IRQ
829:                   INTCON2bits.INT0EP = 0; // edge polarity, interrupt on positive edge
001E0E  A90082     BCLR INTCON2, #0
830:                   IPC0bits.INT0IP = 0x03; // cap touch input interrupt priority level
001E10  800521     MOV IPC0, W1
001E12  2FFF80     MOV #0xFFF8, W0
001E14  608000     AND W1, W0, W0
001E16  B30030     IOR #0x3, W0
001E18  880520     MOV W0, IPC0
831:                   IFS0bits.INT0IF = 0;    // clear interrupt flag
001E1A  A90084     BCLR IFS0, #0
832:                   IEC0bits.INT0IE = 1;    // enable external interrupt
001E1C  A80094     BSET IEC0, #0
833:               
834:               }
001E1E  FA8000     ULNK
001E20  060000     RETURN
---  H:/ecen4013/integration2/integration2.X/logics.c  --------------------------------------------------
1:                 /*
2:                  *  YEAAAHAHAHAHAHAHAH
3:                  *  
4:                  *  Colt Wilkens wrote this one too.
5:                  */
6:                 
7:                 #include <p24HJ64GP502.h>
8:                 
9:                 #include <stdbool.h>
10:                #include <stdlib.h>
11:                #include <stdio.h>
12:                #include <string.h>
13:                #include "logics.h"
14:                
15:                // PROTOTYPING STUFF (ie uart output)
16:                void uart_newline() {
0029B4  FA0000     LNK #0x0
17:                    U1TXREG = '\r';
0029B6  2000D0     MOV #0xD, W0
0029B8  881120     MOV W0, U1TXREG
18:                    while (U1STAbits.TRMT == 0) {}; // wait while transmitting
0029BA  000000     NOP
0029BC  801111     MOV U1STA, W1
0029BE  201000     MOV #0x100, W0
0029C0  608000     AND W1, W0, W0
0029C2  500FE0     SUB W0, #0x0, [W15]
0029C4  32FFFB     BRA Z, 0x29BC
19:                    U1TXREG = '\n';
0029C6  2000A0     MOV #0xA, W0
0029C8  881120     MOV W0, U1TXREG
20:                    while (U1STAbits.TRMT == 0) {}; // wait while transmitting
0029CA  000000     NOP
0029CC  801111     MOV U1STA, W1
0029CE  201000     MOV #0x100, W0
0029D0  608000     AND W1, W0, W0
0029D2  500FE0     SUB W0, #0x0, [W15]
0029D4  32FFFB     BRA Z, 0x29CC
21:                }
0029D6  FA8000     ULNK
0029D8  060000     RETURN
22:                
23:                void uart_chrstr(char* string) {
0029DA  FA0004     LNK #0x4
0029DC  980710     MOV W0, [W14+2]
24:                    int i = 0;
0029DE  EB0000     CLR W0
0029E0  780F00     MOV W0, [W14]
25:                    while (string[i] != '\0') {
0029E2  37000D     BRA 0x29FE
0029FE  78001E     MOV [W14], W0
002A00  90009E     MOV [W14+2], W1
002A02  408000     ADD W1, W0, W0
002A04  784010     MOV.B [W0], W0
002A06  504FE0     SUB.B W0, #0x0, [W15]
002A08  3AFFED     BRA NZ, 0x29E4
26:                        U1TXREG = string[i];
0029E4  78001E     MOV [W14], W0
0029E6  90009E     MOV [W14+2], W1
0029E8  408000     ADD W1, W0, W0
0029EA  784010     MOV.B [W0], W0
0029EC  FB0000     SE W0, W0
0029EE  881120     MOV W0, U1TXREG
27:                        i++;
0029F0  E80F1E     INC [W14], [W14]
28:                        while (U1STAbits.TRMT == 0) {}; // wait while transmitting
0029F2  000000     NOP
0029F4  801111     MOV U1STA, W1
0029F6  201000     MOV #0x100, W0
0029F8  608000     AND W1, W0, W0
0029FA  500FE0     SUB W0, #0x0, [W15]
0029FC  32FFFB     BRA Z, 0x29F4
29:                    }
30:                }
002A0A  FA8000     ULNK
002A0C  060000     RETURN
31:                
32:                // EVERYBODYS LOGIC FUNCTIONS STUFF
33:                
34:                /*void update_ammo(int amount) {
35:                    char number[ITOASIZE] = "";
36:                    itoa(number, amount, 10);
37:                    uart_chrstr("ammo level at ");
38:                    uart_chrstr(number);
39:                    uart_newline();
40:                };*/
41:                
42:                /*void update_health(int health) {
43:                    char number[ITOASIZE] = "";
44:                    itoa(number, health, 10);
45:                    uart_chrstr("health at ");
46:                    uart_chrstr(number);
47:                    uart_newline();
48:                };*/
49:                
50:                /*void update_load(bool loaded) {
51:                    if (loaded)
52:                        uart_chrstr("bolt loaded!");
53:                    else
54:                        uart_chrstr("no bolt loaded...");
55:                    uart_newline();
56:                };*/
57:                
58:                /*void update_led_bar(int bar_bits) {
59:                    char number[ITOASIZE] = "";
60:                    itoa(number, bar_bits, 2);
61:                    uart_chrstr("led bar: ");
62:                    uart_chrstr(number);
63:                    uart_newline();
64:                };*/
65:                
66:                /*void fire_display(bool firing) {
67:                    if (firing)
68:                        uart_chrstr("firing bolt!");
69:                    else
70:                        uart_chrstr("not firing...");
71:                    uart_newline();
72:                };*/
73:                
74:                /*void cooldown_display(int count) {
75:                    char number[ITOASIZE] = "";
76:                    itoa(number, count, 10);
77:                    uart_chrstr("cooldown at ");
78:                    uart_chrstr(number);
79:                    uart_newline();
80:                };*/
81:                
82:                
83:                // CAN logic
84:                /*bool im_dead() {
85:                    uart_chrstr("you're totally dead, dude.");
86:                    uart_newline();
87:                    return true;
88:                };*/
89:                
90:                // sound logic
91:                /*void play_sound(int soundnumber) {
92:                    char number[ITOASIZE] = "";
93:                    itoa(number, soundnumber, 10);
94:                    uart_chrstr("playing sound ");
95:                    uart_chrstr(number);
96:                    uart_newline();
97:                };*/
98:                
99:                // IR logic
100:               enum MIRP receive_packet() {
002A0E  FA0000     LNK #0x0
101:                   // lol
102:                   //return 5;
103:                   /*
104:                    *  NOTE: code adapted from reference headband:
105:                    *  https://code.google.com/p/devmage/source/browse/sw/reference-headband.X/main.c
106:                    * 
107:                    */
108:                   return ERROR;
002A10  EB0000     CLR W0
109:               
110:               };
002A12  FA8000     ULNK
002A14  060000     RETURN
111:               
112:               // send SPI command for IR TX
113:               /*void set_ir_tx(char bits)
114:               {
115:                   uart_chrstr("setting IR tx: ");
116:                   uart_binary(bits);
117:                   uart_newline();
118:                   // shift bits out to IR TX
119:                   // msb becomes OUT7, lsb is OUT0
120:                   int i;
121:                   for(i = 0; i < 8; i++)
122:                   {
123:                       ir_clk = 0;
124:                       ir_data = (bits >> (7-i)) & 0x1;
125:                       ir_clk = 1;
126:                   }
127:               }*/
128:               
129:               void signal_on(unsigned char a) {
002A16  FA0004     LNK #0x4
002A18  984720     MOV.B W0, [W14+2]
130:                   int i;
131:                   for(i = 0; i <= a; i++) {
002A1A  EB0000     CLR W0
002A1C  780F00     MOV W0, [W14]
002A1E  37003E     BRA 0x2A9C
002A9A  E80F1E     INC [W14], [W14]
002A9C  90402E     MOV.B [W14+2], W0
002A9E  FB8000     ZE W0, W0
002AA0  500F9E     SUB W0, [W14], [W15]
002AA2  3DFFBE     BRA GE, 0x2A20
132:                       ir_tx = 1;
002A20  A882CC     BSET LATB, #4
133:                       Nop();
002A22  000000     NOP
134:                       Nop();
002A24  000000     NOP
135:                       Nop();
002A26  000000     NOP
136:                       Nop();
002A28  000000     NOP
137:                       Nop();
002A2A  000000     NOP
138:                       Nop();
002A2C  000000     NOP
139:                       Nop();
002A2E  000000     NOP
140:                       Nop();
002A30  000000     NOP
141:                       Nop();
002A32  000000     NOP
142:                       Nop();
002A34  000000     NOP
143:                       Nop();
002A36  000000     NOP
144:                       Nop();
002A38  000000     NOP
145:                       Nop();
002A3A  000000     NOP
146:                       Nop();
002A3C  000000     NOP
147:                       Nop();
002A3E  000000     NOP
148:                       Nop();
002A40  000000     NOP
149:                       Nop();
002A42  000000     NOP
150:                       Nop();
002A44  000000     NOP
151:                       Nop();
002A46  000000     NOP
152:                       Nop();
002A48  000000     NOP
153:                       Nop();
002A4A  000000     NOP
154:                       Nop();
002A4C  000000     NOP
155:                       Nop();
002A4E  000000     NOP
156:                       Nop();
002A50  000000     NOP
157:                       Nop();
002A52  000000     NOP
158:                       Nop();
002A54  000000     NOP
159:                       Nop();
002A56  000000     NOP
160:                       Nop();
002A58  000000     NOP
161:                       Nop();
002A5A  000000     NOP
162:                       Nop();
002A5C  000000     NOP
163:                       ir_tx = 0;
002A5E  A982CC     BCLR LATB, #4
164:                       Nop();
002A60  000000     NOP
165:                       Nop();
002A62  000000     NOP
166:                       Nop();
002A64  000000     NOP
167:                       Nop();
002A66  000000     NOP
168:                       Nop();
002A68  000000     NOP
169:                       Nop();
002A6A  000000     NOP
170:                       Nop();
002A6C  000000     NOP
171:                       Nop();
002A6E  000000     NOP
172:                       Nop();
002A70  000000     NOP
173:                       Nop();
002A72  000000     NOP
174:                       Nop();
002A74  000000     NOP
175:                       Nop();
002A76  000000     NOP
176:                       Nop();
002A78  000000     NOP
177:                       Nop();
002A7A  000000     NOP
178:                       Nop();
002A7C  000000     NOP
179:                       Nop();
002A7E  000000     NOP
180:                       Nop();
002A80  000000     NOP
181:                       Nop();
002A82  000000     NOP
182:                       Nop();
002A84  000000     NOP
183:                       Nop();
002A86  000000     NOP
184:                       Nop();
002A88  000000     NOP
185:                       Nop();
002A8A  000000     NOP
186:                       Nop();
002A8C  000000     NOP
187:                       Nop();
002A8E  000000     NOP
188:                       Nop();
002A90  000000     NOP
189:                       Nop();
002A92  000000     NOP
190:                       Nop();
002A94  000000     NOP
191:                       Nop();
002A96  000000     NOP
192:                       Nop();
002A98  000000     NOP
193:                   }
194:               }
002AA4  FA8000     ULNK
002AA6  060000     RETURN
195:               
196:               void signal_off(unsigned char b) {
002AA8  FA0004     LNK #0x4
002AAA  984720     MOV.B W0, [W14+2]
197:                   int i;
198:                   for(i = 0; i <= b; i++) {
002AAC  EB0000     CLR W0
002AAE  780F00     MOV W0, [W14]
002AB0  37003E     BRA 0x2B2E
002B2C  E80F1E     INC [W14], [W14]
002B2E  90402E     MOV.B [W14+2], W0
002B30  FB8000     ZE W0, W0
002B32  500F9E     SUB W0, [W14], [W15]
002B34  3DFFBE     BRA GE, 0x2AB2
199:                       ir_tx = 1;
002AB2  A882CC     BSET LATB, #4
200:                       Nop();
002AB4  000000     NOP
201:                       Nop();
002AB6  000000     NOP
202:                       Nop();
002AB8  000000     NOP
203:                       Nop();
002ABA  000000     NOP
204:                       Nop();
002ABC  000000     NOP
205:                       Nop();
002ABE  000000     NOP
206:                       Nop();
002AC0  000000     NOP
207:                       Nop();
002AC2  000000     NOP
208:                       Nop();
002AC4  000000     NOP
209:                       Nop();
002AC6  000000     NOP
210:                       Nop();
002AC8  000000     NOP
211:                       Nop();
002ACA  000000     NOP
212:                       Nop();
002ACC  000000     NOP
213:                       Nop();
002ACE  000000     NOP
214:                       Nop();
002AD0  000000     NOP
215:                       Nop();
002AD2  000000     NOP
216:                       Nop();
002AD4  000000     NOP
217:                       Nop();
002AD6  000000     NOP
218:                       Nop();
002AD8  000000     NOP
219:                       Nop();
002ADA  000000     NOP
220:                       Nop();
002ADC  000000     NOP
221:                       Nop();
002ADE  000000     NOP
222:                       Nop();
002AE0  000000     NOP
223:                       Nop();
002AE2  000000     NOP
224:                       Nop();
002AE4  000000     NOP
225:                       Nop();
002AE6  000000     NOP
226:                       Nop();
002AE8  000000     NOP
227:                       Nop();
002AEA  000000     NOP
228:                       Nop();
002AEC  000000     NOP
229:                       Nop();
002AEE  000000     NOP
230:                       ir_tx = 1;
002AF0  A882CC     BSET LATB, #4
231:                       Nop();
002AF2  000000     NOP
232:                       Nop();
002AF4  000000     NOP
233:                       Nop();
002AF6  000000     NOP
234:                       Nop();
002AF8  000000     NOP
235:                       Nop();
002AFA  000000     NOP
236:                       Nop();
002AFC  000000     NOP
237:                       Nop();
002AFE  000000     NOP
238:                       Nop();
002B00  000000     NOP
239:                       Nop();
002B02  000000     NOP
240:                       Nop();
002B04  000000     NOP
241:                       Nop();
002B06  000000     NOP
242:                       Nop();
002B08  000000     NOP
243:                       Nop();
002B0A  000000     NOP
244:                       Nop();
002B0C  000000     NOP
245:                       Nop();
002B0E  000000     NOP
246:                       Nop();
002B10  000000     NOP
247:                       Nop();
002B12  000000     NOP
248:                       Nop();
002B14  000000     NOP
249:                       Nop();
002B16  000000     NOP
250:                       Nop();
002B18  000000     NOP
251:                       Nop();
002B1A  000000     NOP
252:                       Nop();
002B1C  000000     NOP
253:                       Nop();
002B1E  000000     NOP
254:                       Nop();
002B20  000000     NOP
255:                       Nop();
002B22  000000     NOP
256:                       Nop();
002B24  000000     NOP
257:                       Nop();
002B26  000000     NOP
258:                       Nop();
002B28  000000     NOP
259:                       Nop();
002B2A  000000     NOP
260:                   }
261:               }
002B36  FA8000     ULNK
002B38  060000     RETURN
262:               
263:               void MIRPHit() {
002B3A  FA0000     LNK #0x0
264:                   signal_on(10);
002B3C  B3C0A0     MOV #0xA, W0
002B3E  07FF6B     RCALL signal_on
265:                   signal_off(140);
002B40  B3C8C0     MOV #0x8C, W0
002B42  07FFB2     RCALL signal_off
266:               
267:                   signal_on(20);
002B44  B3C140     MOV #0x14, W0
002B46  07FF67     RCALL signal_on
268:                   signal_off(130);
002B48  B3C820     MOV #0x82, W0
002B4A  07FFAE     RCALL signal_off
269:                   signal_on(20);
002B4C  B3C140     MOV #0x14, W0
002B4E  07FF63     RCALL signal_on
270:                   signal_off(130);
002B50  B3C820     MOV #0x82, W0
002B52  07FFAA     RCALL signal_off
271:               
272:                   signal_on(100);
002B54  B3C640     MOV #0x64, W0
002B56  07FF5F     RCALL signal_on
273:               }
002B58  FA8000     ULNK
002B5A  060000     RETURN
274:               void shoot_packet(int strength) {
002B5C  FA0018     LNK #0x18
002B5E  980F30     MOV W0, [W14+22]
275:                   char number[ITOASIZE] = "";
002B60  B80060     MUL.UU W0, #0, W0
002B62  980720     MOV W0, [W14+4]
002B64  980731     MOV W1, [W14+6]
002B66  78000E     MOV W14, W0
002B68  B00080     ADD #0x8, W0
002B6A  090005     REPEAT #0x5
002B6C  EB1800     CLR [W0++]
002B6E  EB5800     CLR.B [W0++]
276:                   itoa(number, strength, 10);
002B70  470064     ADD W14, #0x4, W0
002B72  2000A2     MOV #0xA, W2
002B74  9008BE     MOV [W14+22], W1
002B76  07EBA8     RCALL _itoa
277:                   uart_chrstr("shooting MIRP packet with strength of ");
002B78  296FE0     MOV #0x96FE, W0
002B7A  07FF2F     RCALL uart_chrstr
278:                   uart_chrstr(number);
002B7C  470064     ADD W14, #0x4, W0
002B7E  07FF2D     RCALL uart_chrstr
279:                   uart_newline();
002B80  07FF19     RCALL uart_newline
280:               
281:                   // IO to set power level
282:                   /*switch (strength) {
283:                       case 8:
284:                           set_ir_tx(0b10000000); // pins are inverted
285:                           break;
286:                       case 7:
287:                           set_ir_tx(0b01000000);
288:                           break;
289:                       case 6:
290:                           set_ir_tx(0b00100000);
291:                           break;
292:                       case 5:
293:                           set_ir_tx(0b00010000);
294:                           break;
295:                       case 4:
296:                           set_ir_tx(0b00001000);
297:                           break;
298:                       case 3:
299:                           set_ir_tx(0b00000100);
300:                           break;
301:                       case 2:
302:                           set_ir_tx(0b00000010);
303:                           break;
304:                       case 1:
305:                       default:
306:                           set_ir_tx(0b00000001);
307:                           break;
308:                   }*/
309:               
310:                   // shoot packet
311:                   int i, j;
312:                   for(i = 0; i < 3*strength; i++)
002B82  EB0000     CLR W0
002B84  780F00     MOV W0, [W14]
002B86  37000D     BRA 0x2BA2
002BA0  E80F1E     INC [W14], [W14]
002BA2  90083E     MOV [W14+22], W0
002BA4  B90063     MUL.SU W0, #3, W0
002BA6  780000     MOV W0, W0
002BA8  500F9E     SUB W0, [W14], [W15]
002BAA  3CFFEE     BRA GT, 0x2B88
313:                   {
314:                       //signal_on(200);
315:                       for(j = 0; j < 1800; j++)
002B88  EB0000     CLR W0
002B8A  980710     MOV W0, [W14+2]
002B8C  370004     BRA 0x2B96
002B90  90001E     MOV [W14+2], W0
002B92  E80000     INC W0, W0
002B94  980710     MOV W0, [W14+2]
002B96  90009E     MOV [W14+2], W1
002B98  207070     MOV #0x707, W0
002B9A  508F80     SUB W1, W0, [W15]
002B9C  34FFF8     BRA LE, 0x2B8E
316:                           Nop();
002B8E  000000     NOP
317:                           //signal_on(10);
318:                       MIRPHit();
002B9E  07FFCD     RCALL MIRPHit
319:                       
320:                   }
321:               
322:                   // set shift reg back to all high just to make sure the TX is off
323:                   //set_ir_tx(0x00);
324:               };
002BAC  FA8000     ULNK
002BAE  060000     RETURN
325:               
---  H:/ecen4013/integration2/integration2.X/ledbar.c  --------------------------------------------------
1:                 // written by Colt Wilkens
2:                 // April 3, 2014
3:                 // part of Crossbow 2.0 for the MAGE system
4:                 
5:                 #include <p24HJ64GP502.h>
6:                 
7:                 #include <stdbool.h>
8:                 #include <stdlib.h>
9:                 #include <string.h>
10:                #include "logics.h"
11:                
12:                // see logics.h for pinout #defines
13:                
14:                void LED_init()
15:                {
002EFA  FA0000     LNK #0x0
16:                    // init zeros to LED bars
17:                    update_led_bar(0);
002EFC  EB0000     CLR W0
002EFE  070002     RCALL update_led_bar
18:                }
002F00  FA8000     ULNK
002F02  060000     RETURN
19:                
20:                
21:                void update_led_bar(int bar_bits)
22:                {
002F04  FA0016     LNK #0x16
002F06  980F20     MOV W0, [W14+20]
23:                    char number[ITOASIZE] = "";
002F08  B80060     MUL.UU W0, #0, W0
002F0A  980710     MOV W0, [W14+2]
002F0C  980721     MOV W1, [W14+4]
002F0E  78000E     MOV W14, W0
002F10  B00060     ADD #0x6, W0
002F12  090005     REPEAT #0x5
002F14  EB1800     CLR [W0++]
002F16  EB5800     CLR.B [W0++]
24:                    itoa(number, bar_bits, 2);
002F18  E8800E     INC2 W14, W0
002F1A  200022     MOV #0x2, W2
002F1C  9008AE     MOV [W14+20], W1
002F1E  07E9D4     RCALL _itoa
25:                    uart_chrstr("led bar: ");
002F20  297520     MOV #0x9752, W0
002F22  07FD5B     RCALL uart_chrstr
26:                    uart_chrstr(number);
002F24  E8800E     INC2 W14, W0
002F26  07FD59     RCALL uart_chrstr
27:                    uart_newline();
002F28  07FD45     RCALL uart_newline
28:                    // shift bits out to LED bar
29:                    int i;
30:                    for(i = 0; i < 8; i++)
002F2A  EB0000     CLR W0
002F2C  780F00     MOV W0, [W14]
002F2E  370012     BRA 0x2F54
002F52  E80F1E     INC [W14], [W14]
002F54  78001E     MOV [W14], W0
002F56  500FE7     SUB W0, #0x7, [W15]
002F58  34FFEB     BRA LE, 0x2F30
31:                    {
32:                        led_clk = 0;
002F30  A902C4     BCLR LATA, #0
33:                        led_data = (bar_bits >> i) & 0x1;
002F32  9008AE     MOV [W14+20], W1
002F34  78001E     MOV [W14], W0
002F36  DE8800     ASR W1, W0, W0
002F38  784000     MOV.B W0, W0
002F3A  604061     AND.B W0, #0x1, W0
002F3C  604061     AND.B W0, #0x1, W0
002F3E  604061     AND.B W0, #0x1, W0
002F40  FB8000     ZE W0, W0
002F42  600061     AND W0, #0x1, W0
002F44  400000     ADD W0, W0, W0
002F46  801622     MOV LATA, W2
002F48  2FFFD1     MOV #0xFFFD, W1
002F4A  610081     AND W2, W1, W1
002F4C  708000     IOR W1, W0, W0
002F4E  881620     MOV W0, LATA
34:                        led_clk = 1;
002F50  A802C4     BSET LATA, #0
35:                    }
36:                    //led_ss = 1;
37:                }
002F5A  FA8000     ULNK
002F5C  060000     RETURN
---  H:/ecen4013/integration2/integration2.X/captouch.c  ------------------------------------------------
1:                 /*
2:                  *
3:                  * Hey, did you hear about how Colt Wilkens wrote this one too?
4:                  *
5:                  */
6:                 
7:                 #include <p24HJ64GP502.h>
8:                 
9:                 #include <stdbool.h>
10:                #include <stdlib.h>
11:                #include <string.h>
12:                #include "captouch.h"
13:                
14:                //#include <i2c.h>
15:                
16:                // I2C stuff
17:                // FCY = 3.685 MHz
18:                // FSCL = 100 kHz
19:                // I2CBRG = (FCY/FSCL - FCY/10,000,000) - 1 = 35.4815
20:                //I2C1BRG = 35;
21:                #define I2C_BRG 35
22:                #define lenArray(arr)  (sizeof(arr)/sizeof(arr[0]))
23:                
24:                char touchdata[TOUCHSIZE+1];
25:                unsigned char slaveaddr;
26:                
27:                void uart_binary(char value)
28:                {
001E22  FA0006     LNK #0x6
001E24  984740     MOV.B W0, [W14+4]
29:                    int i;
30:                    char temp = value;
001E26  90404E     MOV.B [W14+4], W0
001E28  984720     MOV.B W0, [W14+2]
31:                    for(i = 0; i < 8; i++) {
001E2A  EB0000     CLR W0
001E2C  780F00     MOV W0, [W14]
001E2E  37000D     BRA 0x1E4A
001E48  E80F1E     INC [W14], [W14]
001E4A  78001E     MOV [W14], W0
001E4C  500FE7     SUB W0, #0x7, [W15]
001E4E  34FFF0     BRA LE, 0x1E30
32:                        if (temp & 0x80)
001E30  90402E     MOV.B [W14+2], W0
001E32  504FE0     SUB.B W0, #0x0, [W15]
001E34  3D0003     BRA GE, 0x1E3C
33:                            uart_chrstr("1");
001E36  296740     MOV #0x9674, W0
001E38  0705D0     RCALL uart_chrstr
001E3A  370002     BRA 0x1E40
34:                        else
35:                            uart_chrstr("0");
001E3C  296760     MOV #0x9676, W0
001E3E  0705CD     RCALL uart_chrstr
36:                        temp = temp << 1;
001E40  90402E     MOV.B [W14+2], W0
001E42  FB0000     SE W0, W0
001E44  400000     ADD W0, W0, W0
001E46  984720     MOV.B W0, [W14+2]
37:                    }
38:                }
001E50  FA8000     ULNK
001E52  060000     RETURN
39:                
40:                void uart_binary_16(int value)
41:                {
001E54  FA0006     LNK #0x6
001E56  980720     MOV W0, [W14+4]
42:                    int i;
43:                    int temp = value;
001E58  90002E     MOV [W14+4], W0
001E5A  980710     MOV W0, [W14+2]
44:                    for(i = 0; i < 16; i++) {
001E5C  EB0000     CLR W0
001E5E  780F00     MOV W0, [W14]
001E60  37000E     BRA 0x1E7E
001E7C  E80F1E     INC [W14], [W14]
001E7E  78001E     MOV [W14], W0
001E80  500FEF     SUB W0, #0xF, [W15]
001E82  34FFEF     BRA LE, 0x1E62
45:                        if ( (temp >> (15-i)) & 0x0001)
001E62  2000F1     MOV #0xF, W1
001E64  50801E     SUB W1, [W14], W0
001E66  90009E     MOV [W14+2], W1
001E68  DE8800     ASR W1, W0, W0
001E6A  600061     AND W0, #0x1, W0
001E6C  784000     MOV.B W0, W0
001E6E  504FE0     SUB.B W0, #0x0, [W15]
001E70  320003     BRA Z, 0x1E78
46:                            uart_chrstr("1");
001E72  296740     MOV #0x9674, W0
001E74  0705B2     RCALL uart_chrstr
001E76  370002     BRA 0x1E7C
47:                        else
48:                            uart_chrstr("0");
001E78  296760     MOV #0x9676, W0
001E7A  0705AF     RCALL uart_chrstr
49:                        //temp = temp << 1;
50:                    }
51:                }
001E84  FA8000     ULNK
001E86  060000     RETURN
52:                
53:                //loop nops for delay
54:                void DelayuSec(unsigned int N)
55:                {
001E88  FA0004     LNK #0x4
001E8A  980710     MOV W0, [W14+2]
56:                   unsigned int j;
57:                   while(N > 0)
001E8C  37000A     BRA 0x1EA2
001EA2  90001E     MOV [W14+2], W0
001EA4  500FE0     SUB W0, #0x0, [W15]
001EA6  3AFFF3     BRA NZ, 0x1E8E
58:                   {
59:                      for(j=0;j < 10; j++);
001E8E  EB0000     CLR W0
001E90  780F00     MOV W0, [W14]
001E92  370001     BRA 0x1E96
001E94  E80F1E     INC [W14], [W14]
001E96  78001E     MOV [W14], W0
001E98  500FE9     SUB W0, #0x9, [W15]
001E9A  36FFFC     BRA LEU, 0x1E94
60:                      N--;
001E9C  90001E     MOV [W14+2], W0
001E9E  E90000     DEC W0, W0
001EA0  980710     MOV W0, [W14+2]
61:                   }
62:                }
001EA8  FA8000     ULNK
001EAA  060000     RETURN
63:                
64:                /*
65:                 *   i2c_* functions taken from:
66:                 *   http://www.engscope.com/pic24-tutorial/10-2-i2c-basic-functions/
67:                 *
68:                 */
69:                
70:                //Resets the I2C bus to Idle
71:                void reset_i2c_bus(void)
72:                {
001EAC  FA0002     LNK #0x2
73:                   int x = 0;
001EAE  EB0000     CLR W0
001EB0  780F00     MOV W0, [W14]
74:                
75:                   //initiate stop bit
76:                   I2C1CONbits.PEN = 1;
001EB2  A84206     BSET I2C1CON, #2
77:                
78:                   //wait for hardware clear of stop bit
79:                   while (I2C1CONbits.PEN)
001EB4  370006     BRA 0x1EC2
001EC2  801030     MOV I2C1CON, W0
001EC4  600064     AND W0, #0x4, W0
001EC6  500FE0     SUB W0, #0x0, [W15]
001EC8  3AFFF6     BRA NZ, 0x1EB6
001ECA  370001     BRA 0x1ECE
80:                   {
81:                      DelayuSec(1);
001EB6  200010     MOV #0x1, W0
001EB8  07FFE7     RCALL DelayuSec
82:                      x ++;
001EBA  E80F1E     INC [W14], [W14]
83:                      if (x > 20) break;
001EBC  78001E     MOV [W14], W0
001EBE  500FF4     SUB W0, #0x14, [W15]
001EC0  3C0005     BRA GT, 0x1ECC
001ECC  000000     NOP
84:                   }
85:                   I2C1CONbits.RCEN = 0;
001ECE  A96206     BCLR I2C1CON, #3
86:                   IFS1bits.MI2C1IF = 0; // Clear Interrupt
001ED0  A92086     BCLR IFS1, #1
87:                   I2C1STATbits.IWCOL = 0;
001ED2  A9E208     BCLR I2C1STAT, #7
88:                   I2C1STAT = I2C1STAT & 0xFBFF;
001ED4  801041     MOV I2C1STAT, W1
001ED6  2FBFF0     MOV #0xFBFF, W0
001ED8  608000     AND W1, W0, W0
001EDA  881040     MOV W0, I2C1STAT
89:                   //I2C1STATbits.BCL = 0; // see above (and silicon errata)
90:                   DelayuSec(10);
001EDC  2000A0     MOV #0xA, W0
001EDE  07FFD4     RCALL DelayuSec
91:                }
001EE0  FA8000     ULNK
001EE2  060000     RETURN
92:                
93:                //function initiates I2C1 module to baud rate BRG
94:                void i2c_init()
95:                {
001EE4  FA0002     LNK #0x2
96:                   int temp;
97:                
98:                   I2C1BRG = I2C_BRG;
001EE6  200230     MOV #0x23, W0
001EE8  881020     MOV W0, I2C1BRG
99:                   I2C1CONbits.I2CEN = 0;	// Disable I2C Mode
001EEA  A9E207     BCLR 0x207, #7
100:                  I2C1CONbits.DISSLW = 1;	// Disable slew rate control
001EEC  A82207     BSET 0x207, #1
101:                  IFS1bits.MI2C1IF = 0;	 // Clear Interrupt
001EEE  A92086     BCLR IFS1, #1
102:                  I2C1CONbits.I2CEN = 1;	// Enable I2C Mode
001EF0  A8E207     BSET 0x207, #7
103:                  temp = I2CRCV;	 // read buffer to clear buffer full
001EF2  801000     MOV I2C1RCV, W0
001EF4  780F00     MOV W0, [W14]
104:                  reset_i2c_bus();	 // set bus to idle
001EF6  07FFDA     RCALL reset_i2c_bus
105:               }
001EF8  FA8000     ULNK
001EFA  060000     RETURN
106:               
107:               //function iniates a start condition on bus
108:               void i2c_start(void)
109:               {
001EFC  FA0002     LNK #0x2
110:                  int x = 0;
001EFE  EB0000     CLR W0
001F00  780F00     MOV W0, [W14]
111:                  I2C1CONbits.ACKDT = 0;	//Reset any previous Ack
001F02  A9A206     BCLR I2C1CON, #5
112:                  DelayuSec(10);
001F04  2000A0     MOV #0xA, W0
001F06  07FFC0     RCALL DelayuSec
113:                  I2C1CONbits.SEN = 1;	//Initiate Start condition
001F08  A80206     BSET I2C1CON, #0
114:                  Nop();
001F0A  000000     NOP
115:               
116:                  //the hardware will automatically clear Start Bit
117:                  //wait for automatic clear before proceding
118:                  while (I2C1CONbits.SEN)
001F0C  370006     BRA 0x1F1A
001F1A  801030     MOV I2C1CON, W0
001F1C  600061     AND W0, #0x1, W0
001F1E  500FE0     SUB W0, #0x0, [W15]
001F20  3AFFF6     BRA NZ, 0x1F0E
001F22  370001     BRA 0x1F26
119:                  {
120:                     DelayuSec(1);
001F0E  200010     MOV #0x1, W0
001F10  07FFBB     RCALL DelayuSec
121:                     x++;
001F12  E80F1E     INC [W14], [W14]
122:                     if (x > 20)
001F14  78001E     MOV [W14], W0
001F16  500FF4     SUB W0, #0x14, [W15]
001F18  3C0005     BRA GT, 0x1F24
123:                     break;
001F24  000000     NOP
124:                  }
125:                  DelayuSec(2);
001F26  200020     MOV #0x2, W0
001F28  07FFAF     RCALL DelayuSec
126:               }
001F2A  FA8000     ULNK
001F2C  060000     RETURN
127:               
128:               void i2c_restart(void)
129:               {
001F2E  FA0002     LNK #0x2
130:                  int x = 0;
001F30  EB0000     CLR W0
001F32  780F00     MOV W0, [W14]
131:               
132:                  I2C1CONbits.RSEN = 1;	//Initiate restart condition
001F34  A82206     BSET I2C1CON, #1
133:                  Nop();
001F36  000000     NOP
134:               
135:                  //the hardware will automatically clear restart bit
136:                  //wait for automatic clear before proceding
137:                  while (I2C1CONbits.RSEN)
001F38  370006     BRA 0x1F46
001F46  801030     MOV I2C1CON, W0
001F48  600062     AND W0, #0x2, W0
001F4A  500FE0     SUB W0, #0x0, [W15]
001F4C  3AFFF6     BRA NZ, 0x1F3A
001F4E  370001     BRA 0x1F52
138:                  {
139:                     DelayuSec(1);
001F3A  200010     MOV #0x1, W0
001F3C  07FFA5     RCALL DelayuSec
140:                     x++;
001F3E  E80F1E     INC [W14], [W14]
141:                     if (x > 20)	break;
001F40  78001E     MOV [W14], W0
001F42  500FF4     SUB W0, #0x14, [W15]
001F44  3C0005     BRA GT, 0x1F50
001F50  000000     NOP
142:                  }
143:                  DelayuSec(2);
001F52  200020     MOV #0x2, W0
001F54  07FF99     RCALL DelayuSec
144:               }
001F56  FA8000     ULNK
001F58  060000     RETURN
145:               
146:               //basic I2C byte send
147:               char send_i2c_byte(int data)
148:               {
001F5A  FA0004     LNK #0x4
001F5C  980710     MOV W0, [W14+2]
149:                  int i;
150:               
151:                  while (I2C1STATbits.TBF) { }
001F5E  000000     NOP
001F60  801040     MOV I2C1STAT, W0
001F62  600061     AND W0, #0x1, W0
001F64  500FE0     SUB W0, #0x0, [W15]
001F66  3AFFFC     BRA NZ, 0x1F60
152:                  IFS1bits.MI2C1IF = 0; // Clear Interrupt
001F68  A92086     BCLR IFS1, #1
153:                  I2CTRN = data; // load the outgoing data byte
001F6A  90001E     MOV [W14+2], W0
001F6C  881010     MOV W0, I2C1TRN
154:               
155:                  // wait for transmission
156:                  for (i=0; i<500; i++)
001F6E  EB0000     CLR W0
001F70  780F00     MOV W0, [W14]
001F72  370008     BRA 0x1F84
001F82  E80F1E     INC [W14], [W14]
001F84  201F30     MOV #0x1F3, W0
001F86  78009E     MOV [W14], W1
001F88  508F80     SUB W1, W0, [W15]
001F8A  34FFF4     BRA LE, 0x1F74
001F8C  370001     BRA 0x1F90
157:                  {
158:                     if (!I2C1STATbits.TRSTAT) break;
001F74  801041     MOV I2C1STAT, W1
001F76  240000     MOV #0x4000, W0
001F78  608000     AND W1, W0, W0
001F7A  500FE0     SUB W0, #0x0, [W15]
001F7C  320008     BRA Z, 0x1F8E
001F8E  000000     NOP
159:                     DelayuSec(1);
001F7E  200010     MOV #0x1, W0
001F80  07FF83     RCALL DelayuSec
160:               
161:                     }
162:                     if (i == 500) {
001F90  201F40     MOV #0x1F4, W0
001F92  78009E     MOV [W14], W1
001F94  508F80     SUB W1, W0, [W15]
001F96  3A0004     BRA NZ, 0x1FA0
163:                     uart_chrstr("failed to send?\r\n");
001F98  296780     MOV #0x9678, W0
001F9A  07051F     RCALL uart_chrstr
164:                     return(1);
001F9C  B3C010     MOV #0x1, W0
001F9E  37000D     BRA 0x1FBA
165:                  }
166:               
167:                  // Check for NO_ACK from slave, abort if not found
168:                  if (I2C1STATbits.ACKSTAT == 1)
001FA0  801041     MOV I2C1STAT, W1
001FA2  280000     MOV #0x8000, W0
001FA4  608000     AND W1, W0, W0
001FA6  500FE0     SUB W0, #0x0, [W15]
001FA8  320005     BRA Z, 0x1FB4
169:                  {
170:                      uart_chrstr("no ack\r\n");
001FAA  2968A0     MOV #0x968A, W0
001FAC  070516     RCALL uart_chrstr
171:                     reset_i2c_bus();
001FAE  07FF7E     RCALL reset_i2c_bus
172:                     return(1);
001FB0  B3C010     MOV #0x1, W0
001FB2  370003     BRA 0x1FBA
173:                  }
174:               
175:                  DelayuSec(2);
001FB4  200020     MOV #0x2, W0
001FB6  07FF68     RCALL DelayuSec
176:                  return(0);
001FB8  EB4000     CLR.B W0
177:               }
001FBA  FA8000     ULNK
001FBC  060000     RETURN
178:               
179:               //function reads data, returns the read data, no ack
180:               char i2c_read(void)
181:               {
001FBE  FA0004     LNK #0x4
182:                  int i = 0;
001FC0  EB0000     CLR W0
001FC2  780F00     MOV W0, [W14]
183:                  char data = 0;
001FC4  EB4000     CLR.B W0
001FC6  984720     MOV.B W0, [W14+2]
184:               
185:                  //set I2C module to receive
186:                  I2C1CONbits.RCEN = 1;
001FC8  A86206     BSET I2C1CON, #3
187:               
188:                  //if no response, break
189:                  while (!I2C1STATbits.RBF)
001FCA  370005     BRA 0x1FD6
001FD6  801040     MOV I2C1STAT, W0
001FD8  600062     AND W0, #0x2, W0
001FDA  500FE0     SUB W0, #0x0, [W15]
001FDC  32FFF7     BRA Z, 0x1FCC
001FDE  370001     BRA 0x1FE2
190:                  {
191:                     i ++;
001FCC  E80F1E     INC [W14], [W14]
192:                     if (i > 2000) {
001FCE  207D00     MOV #0x7D0, W0
001FD0  78009E     MOV [W14], W1
001FD2  508F80     SUB W1, W0, [W15]
001FD4  3C0005     BRA GT, 0x1FE0
193:                         //uart_chrstr("Dread:");
194:                         //uart_binary_16(I2C1STAT);
195:                         //uart_newline();
196:                         //uart_chrstr("delayed read.\r\n");
197:                         break;
001FE0  000000     NOP
198:                     }
199:                  }
200:               
201:                  //get data from I2CRCV register
202:                  data = I2CRCV;
001FE2  801000     MOV I2C1RCV, W0
001FE4  984720     MOV.B W0, [W14+2]
203:               
204:                  //return data
205:                  return data;
001FE6  90402E     MOV.B [W14+2], W0
206:               }
001FE8  FA8000     ULNK
001FEA  060000     RETURN
207:               
208:               //function reads data, returns the read data, with ack
209:               char i2c_read_ack(void)	//does not reset bus!!!
210:               {
001FEC  FA0004     LNK #0x4
211:                  int i = 0;
001FEE  EB0000     CLR W0
001FF0  780F00     MOV W0, [W14]
212:                  char data = 0;
001FF2  EB4000     CLR.B W0
001FF4  984720     MOV.B W0, [W14+2]
213:               
214:                  //set I2C module to receive
215:                  I2C1CONbits.RCEN = 1;
001FF6  A86206     BSET I2C1CON, #3
216:               
217:                  //if no response, break
218:                  while (!I2C1STATbits.RBF)
001FF8  370008     BRA 0x200A
00200A  801040     MOV I2C1STAT, W0
00200C  600062     AND W0, #0x2, W0
00200E  500FE0     SUB W0, #0x0, [W15]
002010  32FFF4     BRA Z, 0x1FFA
219:                  {
220:                     i++;
001FFA  E80F1E     INC [W14], [W14]
221:                     if (i > 2000) {
001FFC  207D00     MOV #0x7D0, W0
001FFE  78009E     MOV [W14], W1
002000  508F80     SUB W1, W0, [W15]
002002  340003     BRA LE, 0x200A
222:                         uart_chrstr("\r\n^delayed ack read.^\r\n");
002004  296930     MOV #0x9693, W0
002006  0704E9     RCALL uart_chrstr
223:                         break;
002008  370004     BRA 0x2012
224:                     }
225:                  }
226:               
227:                  //get data from I2CRCV register
228:                  data = I2CRCV;
002012  801000     MOV I2C1RCV, W0
002014  984720     MOV.B W0, [W14+2]
229:               
230:                  //set ACK to high
231:                  I2C1CONbits.ACKEN = 1;
002016  A88206     BSET I2C1CON, #4
232:               
233:                  //wait before exiting
234:                  DelayuSec(10);
002018  2000A0     MOV #0xA, W0
00201A  07FF36     RCALL DelayuSec
235:               
236:                  //return data
237:                  return data;
00201C  90402E     MOV.B [W14+2], W0
238:               }
00201E  FA8000     ULNK
002020  060000     RETURN
239:               
240:               void I2Cwrite(char addr, char subaddr, char value)
241:               {
002022  FA0004     LNK #0x4
002024  784F00     MOV.B W0, [W14]
002026  984711     MOV.B W1, [W14+1]
002028  984722     MOV.B W2, [W14+2]
242:                  i2c_start();
00202A  07FF68     RCALL i2c_start
243:                  send_i2c_byte(addr);
00202C  FB001E     SE [W14], W0
00202E  07FF95     RCALL send_i2c_byte
244:                  send_i2c_byte(subaddr);
002030  90401E     MOV.B [W14+1], W0
002032  FB0000     SE W0, W0
002034  07FF92     RCALL send_i2c_byte
245:                  send_i2c_byte(value);
002036  90402E     MOV.B [W14+2], W0
002038  FB0000     SE W0, W0
00203A  07FF8F     RCALL send_i2c_byte
246:                  reset_i2c_bus();
00203C  07FF37     RCALL reset_i2c_bus
247:               }
00203E  FA8000     ULNK
002040  060000     RETURN
248:               
249:               char I2Cread(char addr, char subaddr)
250:               {
002042  FA0004     LNK #0x4
002044  984720     MOV.B W0, [W14+2]
002046  984731     MOV.B W1, [W14+3]
251:                  char temp;
252:               
253:                  i2c_start();
002048  07FF59     RCALL i2c_start
254:                  send_i2c_byte(addr);
00204A  90402E     MOV.B [W14+2], W0
00204C  FB0000     SE W0, W0
00204E  07FF85     RCALL send_i2c_byte
255:                  send_i2c_byte(subaddr);
002050  90403E     MOV.B [W14+3], W0
002052  FB0000     SE W0, W0
002054  07FF82     RCALL send_i2c_byte
256:                  DelayuSec(10);
002056  2000A0     MOV #0xA, W0
002058  07FF17     RCALL DelayuSec
257:               
258:                  i2c_restart();
00205A  07FF69     RCALL i2c_restart
259:                  send_i2c_byte(addr | 0x01);
00205C  90402E     MOV.B [W14+2], W0
00205E  A00400     BSET.B W0, #0
002060  FB0000     SE W0, W0
002062  07FF7B     RCALL send_i2c_byte
260:                  temp = i2c_read();
002064  07FFAC     RCALL i2c_read
002066  784F00     MOV.B W0, [W14]
261:               
262:                  reset_i2c_bus();
002068  07FF21     RCALL reset_i2c_bus
263:                  return temp;
00206A  78401E     MOV.B [W14], W0
264:               }
00206C  FA8000     ULNK
00206E  060000     RETURN
265:               
266:               void i2c_wait(unsigned int count)
267:               {
002070  FA0002     LNK #0x2
002072  780F00     MOV W0, [W14]
268:                   while (count--)
002074  370002     BRA 0x207A
00207A  EA001E     NEG [W14], W0
00207C  70001E     IOR W0, [W14], W0
00207E  DE004F     LSR W0, #15, W0
002080  784000     MOV.B W0, W0
002082  E90F1E     DEC [W14], [W14]
002084  504FE0     SUB.B W0, #0x0, [W15]
002086  3AFFF7     BRA NZ, 0x2076
269:                   {
270:                       Nop();
002076  000000     NOP
271:                       Nop();
002078  000000     NOP
272:                   }
273:               }
002088  FA8000     ULNK
00208A  060000     RETURN
274:               
275:               
276:               // touch logic
277:               void touch_init() {
00208C  FA0004     LNK #0x4
278:                   // config I2C
279:                   unsigned char i2cbyte;
280:               
281:                   i2c_init();
00208E  07FF2A     RCALL i2c_init
282:               
283:                   unsigned int i; //??
284:                   for(i = 0; i < 4160; i++)
002090  EB0000     CLR W0
002092  780F00     MOV W0, [W14]
002094  370002     BRA 0x209A
002098  E80F1E     INC [W14], [W14]
00209A  2103F0     MOV #0x103F, W0
00209C  78009E     MOV [W14], W1
00209E  508F80     SUB W1, W0, [W15]
0020A0  36FFFA     BRA LEU, 0x2096
285:                   {
286:                       Nop();  // DONT TAKE THIS OUT OR IT FREAKS OUT
002096  000000     NOP
287:                   }
288:                   slaveaddr = 0x5A << 1;
0020A2  B3CB40     MOV #0xB4, W0
0020A4  B7E81F     MOV.B WREG, slaveaddr
289:               
290:                   // Section A
291:                   // This group controls filtering when data is > baseline.
292:                   I2Cwrite(slaveaddr, MHD_R, 0x01);
0020A6  BFC81F     MOV.B slaveaddr, WREG
0020A8  B3C012     MOV #0x1, W2
0020AA  B3C2B1     MOV #0x2B, W1
0020AC  07FFBA     RCALL I2Cwrite
293:                   I2Cwrite(slaveaddr, NHD_R, 0x01);
0020AE  BFC81F     MOV.B slaveaddr, WREG
0020B0  B3C012     MOV #0x1, W2
0020B2  B3C2C1     MOV #0x2C, W1
0020B4  07FFB6     RCALL I2Cwrite
294:                   I2Cwrite(slaveaddr, NCL_R, 0x00);
0020B6  BFC81F     MOV.B slaveaddr, WREG
0020B8  EB4100     CLR.B W2
0020BA  B3C2D1     MOV #0x2D, W1
0020BC  07FFB2     RCALL I2Cwrite
295:                   I2Cwrite(slaveaddr, FDL_R, 0x00);
0020BE  BFC81F     MOV.B slaveaddr, WREG
0020C0  EB4100     CLR.B W2
0020C2  B3C2E1     MOV #0x2E, W1
0020C4  07FFAE     RCALL I2Cwrite
296:               
297:                   // Section B
298:                   // This group controls filtering when data is < baseline.
299:                   I2Cwrite(slaveaddr, MHD_F, 0x01);
0020C6  BFC81F     MOV.B slaveaddr, WREG
0020C8  B3C012     MOV #0x1, W2
0020CA  B3C2F1     MOV #0x2F, W1
0020CC  07FFAA     RCALL I2Cwrite
300:                   I2Cwrite(slaveaddr, NHD_F, 0x01);
0020CE  BFC81F     MOV.B slaveaddr, WREG
0020D0  B3C012     MOV #0x1, W2
0020D2  B3C301     MOV #0x30, W1
0020D4  07FFA6     RCALL I2Cwrite
301:                   I2Cwrite(slaveaddr, NCL_F, 0xFF);
0020D6  BFC81F     MOV.B slaveaddr, WREG
0020D8  EBC100     SETM.B W2
0020DA  B3C311     MOV #0x31, W1
0020DC  07FFA2     RCALL I2Cwrite
302:                   I2Cwrite(slaveaddr, FDL_F, 0x02);
0020DE  BFC81F     MOV.B slaveaddr, WREG
0020E0  B3C022     MOV #0x2, W2
0020E2  B3C321     MOV #0x32, W1
0020E4  07FF9E     RCALL I2Cwrite
303:               
304:                   // Section C
305:                   // This group sets touch and release thresholds for each electrode
306:                   I2Cwrite(slaveaddr, ELE0_T, TOU_THRESH);
0020E6  BFC81F     MOV.B slaveaddr, WREG
0020E8  B3C0F2     MOV #0xF, W2
0020EA  B3C411     MOV #0x41, W1
0020EC  07FF9A     RCALL I2Cwrite
307:                   I2Cwrite(slaveaddr, ELE0_R, REL_THRESH);
0020EE  BFC81F     MOV.B slaveaddr, WREG
0020F0  B3C0A2     MOV #0xA, W2
0020F2  B3C421     MOV #0x42, W1
0020F4  07FF96     RCALL I2Cwrite
308:                   I2Cwrite(slaveaddr, ELE1_T, TOU_THRESH);
0020F6  BFC81F     MOV.B slaveaddr, WREG
0020F8  B3C0F2     MOV #0xF, W2
0020FA  B3C431     MOV #0x43, W1
0020FC  07FF92     RCALL I2Cwrite
309:                   I2Cwrite(slaveaddr, ELE1_R, REL_THRESH);
0020FE  BFC81F     MOV.B slaveaddr, WREG
002100  B3C0A2     MOV #0xA, W2
002102  B3C441     MOV #0x44, W1
002104  07FF8E     RCALL I2Cwrite
310:                   I2Cwrite(slaveaddr, ELE2_T, TOU_THRESH);
002106  BFC81F     MOV.B slaveaddr, WREG
002108  B3C0F2     MOV #0xF, W2
00210A  B3C451     MOV #0x45, W1
00210C  07FF8A     RCALL I2Cwrite
311:                   I2Cwrite(slaveaddr, ELE2_R, REL_THRESH);
00210E  BFC81F     MOV.B slaveaddr, WREG
002110  B3C0A2     MOV #0xA, W2
002112  B3C461     MOV #0x46, W1
002114  07FF86     RCALL I2Cwrite
312:                   I2Cwrite(slaveaddr, ELE3_T, TOU_THRESH);
002116  BFC81F     MOV.B slaveaddr, WREG
002118  B3C0F2     MOV #0xF, W2
00211A  B3C471     MOV #0x47, W1
00211C  07FF82     RCALL I2Cwrite
313:                   I2Cwrite(slaveaddr, ELE3_R, REL_THRESH);
00211E  BFC81F     MOV.B slaveaddr, WREG
002120  B3C0A2     MOV #0xA, W2
002122  B3C481     MOV #0x48, W1
002124  07FF7E     RCALL I2Cwrite
314:                   I2Cwrite(slaveaddr, ELE4_T, TOU_THRESH);
002126  BFC81F     MOV.B slaveaddr, WREG
002128  B3C0F2     MOV #0xF, W2
00212A  B3C491     MOV #0x49, W1
00212C  07FF7A     RCALL I2Cwrite
315:                   I2Cwrite(slaveaddr, ELE4_R, REL_THRESH);
00212E  BFC81F     MOV.B slaveaddr, WREG
002130  B3C0A2     MOV #0xA, W2
002132  B3C4A1     MOV #0x4A, W1
002134  07FF76     RCALL I2Cwrite
316:                   I2Cwrite(slaveaddr, ELE5_T, TOU_THRESH);
002136  BFC81F     MOV.B slaveaddr, WREG
002138  B3C0F2     MOV #0xF, W2
00213A  B3C4B1     MOV #0x4B, W1
00213C  07FF72     RCALL I2Cwrite
317:                   I2Cwrite(slaveaddr, ELE5_R, REL_THRESH);
00213E  BFC81F     MOV.B slaveaddr, WREG
002140  B3C0A2     MOV #0xA, W2
002142  B3C4C1     MOV #0x4C, W1
002144  07FF6E     RCALL I2Cwrite
318:                   I2Cwrite(slaveaddr, ELE6_T, TOU_THRESH);
002146  BFC81F     MOV.B slaveaddr, WREG
002148  B3C0F2     MOV #0xF, W2
00214A  B3C4D1     MOV #0x4D, W1
00214C  07FF6A     RCALL I2Cwrite
319:                   I2Cwrite(slaveaddr, ELE6_R, REL_THRESH);
00214E  BFC81F     MOV.B slaveaddr, WREG
002150  B3C0A2     MOV #0xA, W2
002152  B3C4E1     MOV #0x4E, W1
002154  07FF66     RCALL I2Cwrite
320:                   I2Cwrite(slaveaddr, ELE7_T, TOU_THRESH);
002156  BFC81F     MOV.B slaveaddr, WREG
002158  B3C0F2     MOV #0xF, W2
00215A  B3C4F1     MOV #0x4F, W1
00215C  07FF62     RCALL I2Cwrite
321:                   I2Cwrite(slaveaddr, ELE7_R, REL_THRESH);
00215E  BFC81F     MOV.B slaveaddr, WREG
002160  B3C0A2     MOV #0xA, W2
002162  B3C501     MOV #0x50, W1
002164  07FF5E     RCALL I2Cwrite
322:                   I2Cwrite(slaveaddr, ELE8_T, TOU_THRESH);
002166  BFC81F     MOV.B slaveaddr, WREG
002168  B3C0F2     MOV #0xF, W2
00216A  B3C511     MOV #0x51, W1
00216C  07FF5A     RCALL I2Cwrite
323:                   I2Cwrite(slaveaddr, ELE8_R, REL_THRESH);
00216E  BFC81F     MOV.B slaveaddr, WREG
002170  B3C0A2     MOV #0xA, W2
002172  B3C521     MOV #0x52, W1
002174  07FF56     RCALL I2Cwrite
324:                   I2Cwrite(slaveaddr, ELE9_T, TOU_THRESH);
002176  BFC81F     MOV.B slaveaddr, WREG
002178  B3C0F2     MOV #0xF, W2
00217A  B3C531     MOV #0x53, W1
00217C  07FF52     RCALL I2Cwrite
325:                   I2Cwrite(slaveaddr, ELE9_R, REL_THRESH);
00217E  BFC81F     MOV.B slaveaddr, WREG
002180  B3C0A2     MOV #0xA, W2
002182  B3C541     MOV #0x54, W1
002184  07FF4E     RCALL I2Cwrite
326:                   I2Cwrite(slaveaddr, ELE10_T, TOU_THRESH);
002186  BFC81F     MOV.B slaveaddr, WREG
002188  B3C0F2     MOV #0xF, W2
00218A  B3C551     MOV #0x55, W1
00218C  07FF4A     RCALL I2Cwrite
327:                   I2Cwrite(slaveaddr, ELE10_R, REL_THRESH);
00218E  BFC81F     MOV.B slaveaddr, WREG
002190  B3C0A2     MOV #0xA, W2
002192  B3C561     MOV #0x56, W1
002194  07FF46     RCALL I2Cwrite
328:                   I2Cwrite(slaveaddr, ELE11_T, TOU_THRESH);
002196  BFC81F     MOV.B slaveaddr, WREG
002198  B3C0F2     MOV #0xF, W2
00219A  B3C571     MOV #0x57, W1
00219C  07FF42     RCALL I2Cwrite
329:                   I2Cwrite(slaveaddr, ELE11_R, REL_THRESH);
00219E  BFC81F     MOV.B slaveaddr, WREG
0021A0  B3C0A2     MOV #0xA, W2
0021A2  B3C581     MOV #0x58, W1
0021A4  07FF3E     RCALL I2Cwrite
330:               
331:                   // Section D
332:                   // Set the Filter Configuration
333:                   // Set ESI2
334:                   I2Cwrite(slaveaddr, FIL_CFG, 0x04);
0021A6  BFC81F     MOV.B slaveaddr, WREG
0021A8  B3C042     MOV #0x4, W2
0021AA  B3C5D1     MOV #0x5D, W1
0021AC  07FF3A     RCALL I2Cwrite
335:               
336:                   // Section E
337:                   // Electrode Configuration
338:                   // Enable 6 Electrodes and set to run mode
339:                   // Set ELE_CFG to 0x00 to return to standby mode
340:                   // I2Cwrite(slaveaddr, ELE_CFG, 0x0C);	// Enables all 12 Electrodes
341:                   // Enable first 9 electrodes (0 for tap, 1-9 for swipe)
342:                   I2Cwrite(slaveaddr, ELE_CFG, 0x09);
0021AE  BFC81F     MOV.B slaveaddr, WREG
0021B0  B3C092     MOV #0x9, W2
0021B2  B3C5E1     MOV #0x5E, W1
0021B4  07FF36     RCALL I2Cwrite
343:                   
344:                   // Section F
345:                   // Enable Auto Config and auto Reconfig
346:                   I2Cwrite(slaveaddr, ATO_CFG0, 0x0B);
0021B6  BFC81F     MOV.B slaveaddr, WREG
0021B8  B3C0B2     MOV #0xB, W2
0021BA  B3C7B1     MOV #0x7B, W1
0021BC  07FF32     RCALL I2Cwrite
347:                   I2Cwrite(slaveaddr, ATO_CFGU, 0xC9);	// USL = (Vdd-0.7)/vdd*256 = 0xC9 @3.3V
0021BE  BFC81F     MOV.B slaveaddr, WREG
0021C0  B3CC92     MOV #0xC9, W2
0021C2  B3C7D1     MOV #0x7D, W1
0021C4  07FF2E     RCALL I2Cwrite
348:                   I2Cwrite(slaveaddr, ATO_CFGL, 0x82);	// LSL = 0.65*USL = 0x82 @3.3V
0021C6  BFC81F     MOV.B slaveaddr, WREG
0021C8  B3C822     MOV #0x82, W2
0021CA  B3C7E1     MOV #0x7E, W1
0021CC  07FF2A     RCALL I2Cwrite
349:                   I2Cwrite(slaveaddr, ATO_CFGT, 0xB5);	// Target = 0.9*USL = 0xB5 @3.3V
0021CE  BFC81F     MOV.B slaveaddr, WREG
0021D0  B3CB52     MOV #0xB5, W2
0021D2  B3C7F1     MOV #0x7F, W1
0021D4  07FF26     RCALL I2Cwrite
350:               
351:                   // nullterm touchdata for safety
352:                   touchdata[TOUCHSIZE] = '\0';
0021D6  EB4000     CLR.B W0
0021D8  B7E81E     MOV.B WREG, 0x81E
353:                   uart_chrstr("initializing touch...");
0021DA  296AB0     MOV #0x96AB, W0
0021DC  0703FE     RCALL uart_chrstr
354:                   uart_newline();
0021DE  0703EA     RCALL uart_newline
355:                   
356:                   i2cbyte = I2Cread(slaveaddr, 0x5C);
0021E0  BFC81F     MOV.B slaveaddr, WREG
0021E2  B3C5C1     MOV #0x5C, W1
0021E4  07FF2E     RCALL I2Cread
0021E6  984720     MOV.B W0, [W14+2]
357:                   if (i2cbyte == 16) // default value for ELE_CFG
0021E8  90402E     MOV.B [W14+2], W0
0021EA  504FF0     SUB.B W0, #0x10, [W15]
0021EC  3A0003     BRA NZ, 0x21F4
358:                       uart_chrstr("captouch working!\r\n");
0021EE  296C10     MOV #0x96C1, W0
0021F0  0703F4     RCALL uart_chrstr
0021F2  370002     BRA 0x21F8
359:                   else
360:                       uart_chrstr("captouch failed!\r\n");
0021F4  296D50     MOV #0x96D5, W0
0021F6  0703F1     RCALL uart_chrstr
361:               };
0021F8  FA8000     ULNK
0021FA  060000     RETURN
362:               
363:               // eight bits of previous touch status
364:               char swipe_ele = 0x00;
365:               
366:               touchtype check_touch() {
0021FC  FA000A     LNK #0xA
0021FE  781F88     MOV W8, [W15++]
002200  780400     MOV W0, W8
367:                   touchtype returnval;
368:                   // init structure
369:                   returnval.istap = false;
002202  EB4000     CLR.B W0
002204  984760     MOV.B W0, [W14+6]
370:                   returnval.isswipe = false;
002206  EB4000     CLR.B W0
002208  984770     MOV.B W0, [W14+7]
371:               
372:                   unsigned char i2cbyte, i2cbyte2;
373:                   /*i2cbyte =  I2Cread(slaveaddr, 0x00);
374:               
375:                   // ----------  DEBUG CODE  ---------------
376:                   uart_newline();
377:                   uart_binary(i2cbyte);
378:                   uart_chrstr(" - b");
379:                   i2cbyte =  I2Cread(slaveaddr, 0x01);
380:                   uart_binary(i2cbyte);
381:                   uart_chrstr(" - c");
382:                   i2cbyte =  I2Cread(slaveaddr, 0x02);
383:                   uart_binary(i2cbyte);
384:                   uart_chrstr(" - d");
385:                   i2cbyte =  I2Cread(slaveaddr, 0x03);
386:                   uart_binary(i2cbyte);
387:                   uart_chrstr(" - e");
388:                   i2cbyte =  I2Cread(slaveaddr, ELE_CFG);
389:                   uart_binary(i2cbyte);
390:                   uart_chrstr("\r");*/
391:                   // --- END DEBUG CODE ---
392:               
393:                   i2cbyte =  I2Cread(slaveaddr, 0x00);
00220A  BFC81F     MOV.B slaveaddr, WREG
00220C  EB4080     CLR.B W1
00220E  07FF19     RCALL I2Cread
002210  984720     MOV.B W0, [W14+2]
394:                   i2cbyte2 =  I2Cread(slaveaddr, 0x01);
002212  BFC81F     MOV.B slaveaddr, WREG
002214  B3C011     MOV #0x1, W1
002216  07FF15     RCALL I2Cread
002218  984730     MOV.B W0, [W14+3]
395:                   /*i2c_start();
396:                   send_i2c_byte(slaveaddr);
397:                   send_i2c_byte(0x00);
398:                   DelayuSec(10);
399:               
400:                   i2c_restart();
401:                   send_i2c_byte(slaveaddr | 0x01);
402:                   i2cbyte = i2c_read_ack();
403:                   i2cbyte2 = i2c_read();
404:               
405:                   reset_i2c_bus();*/
406:               
407:                   // combine electrodes
408:                   unsigned int ele = ((i2cbyte2 & 0x0F) << 8) | i2cbyte;
00221A  90403E     MOV.B [W14+3], W0
00221C  FB8000     ZE W0, W0
00221E  60006F     AND W0, #0xF, W0
002220  DD00C8     SL W0, #8, W1
002222  90402E     MOV.B [W14+2], W0
002224  FB8000     ZE W0, W0
002226  708000     IOR W1, W0, W0
002228  980720     MOV W0, [W14+4]
409:               
410:                   if (ele & 0x0100) // ninth bit, ele 8: tap event.
00222A  9000AE     MOV [W14+4], W1
00222C  201000     MOV #0x100, W0
00222E  608000     AND W1, W0, W0
002230  500FE0     SUB W0, #0x0, [W15]
002232  320005     BRA Z, 0x223E
411:                   {
412:                       swipe_ele = 0x00;
002234  EB4000     CLR.B W0
002236  B7E840     MOV.B WREG, 0x840
413:                       returnval.istap = true;
002238  B3C010     MOV #0x1, W0
00223A  984760     MOV.B W0, [W14+6]
00223C  37003A     BRA 0x22B2
414:                   }
415:                   else
416:                   if (ele & 0x00FF) // 8 electrodes (ele 0-7)
00223E  9000AE     MOV [W14+4], W1
002240  200FF0     MOV #0xFF, W0
002242  608000     AND W1, W0, W0
002244  500FE0     SUB W0, #0x0, [W15]
002246  320033     BRA Z, 0x22AE
417:                   {
418:                       // check if ele is the first one, or one next to a previous one
419:                       // pin 0 (bit 0) is actually the highest swipe strength
420:                       // pin 7 (bit 7) is lowest swipe strength
421:                       // loops upwards in swipe strength so always returns higher value
422:                       if (ele & 0x80) {
002248  9000AE     MOV [W14+4], W1
00224A  200800     MOV #0x80, W0
00224C  608000     AND W1, W0, W0
00224E  500FE0     SUB W0, #0x0, [W15]
002250  320007     BRA Z, 0x2260
423:                           returnval.isswipe = true;    // if first electrode is touched
002252  B3C010     MOV #0x1, W0
002254  984770     MOV.B W0, [W14+7]
424:                           returnval.swipestrength = 1;
002256  200010     MOV #0x1, W0
002258  980740     MOV W0, [W14+8]
425:                           swipe_ele = ele; // set for next swipe check
00225A  90002E     MOV [W14+4], W0
00225C  784000     MOV.B W0, W0
00225E  B7E840     MOV.B WREG, 0x840
426:                       }
427:                       int i;
428:                       for(i = 0; i < 8; i++) {
002260  EB0000     CLR W0
002262  780F00     MOV W0, [W14]
002264  370020     BRA 0x22A6
0022A4  E80F1E     INC [W14], [W14]
0022A6  78001E     MOV [W14], W0
0022A8  500FE7     SUB W0, #0x7, [W15]
0022AA  34FFDD     BRA LE, 0x2266
0022AC  370002     BRA 0x22B2
429:                           if ((ele & (0x80 >> i)) && // check if this ele is touched AND
002266  200801     MOV #0x80, W1
002268  78001E     MOV [W14], W0
00226A  DE8800     ASR W1, W0, W0
00226C  780080     MOV W0, W1
00226E  90002E     MOV [W14+4], W0
002270  608000     AND W1, W0, W0
002272  500FE0     SUB W0, #0x0, [W15]
002274  320017     BRA Z, 0x22A4
002282  500FE0     SUB W0, #0x0, [W15]
002284  3A0008     BRA NZ, 0x2296
430:                                 ( (swipe_ele & (0x80 >> (i+1))) ||  // (ele before was touched OR
002276  BFC840     MOV.B 0x840, WREG
002278  FB0080     SE W0, W1
00227A  E8001E     INC [W14], W0
00227C  200802     MOV #0x80, W2
00227E  DE9000     ASR W2, W0, W0
002280  608000     AND W1, W0, W0
002292  500FE0     SUB W0, #0x0, [W15]
002294  320007     BRA Z, 0x22A4
431:                                   (swipe_ele & (0x80 >> (i-1)))     //  ele after was touched)
002286  BFC840     MOV.B 0x840, WREG
002288  FB0080     SE W0, W1
00228A  E9001E     DEC [W14], W0
00228C  200802     MOV #0x80, W2
00228E  DE9000     ASR W2, W0, W0
002290  608000     AND W1, W0, W0
432:                                 )
433:                              )
434:                           {
435:                               returnval.isswipe = true;
002296  B3C010     MOV #0x1, W0
002298  984770     MOV.B W0, [W14+7]
436:                               returnval.swipestrength = i+1;
00229A  E8001E     INC [W14], W0
00229C  980740     MOV W0, [W14+8]
437:                               swipe_ele = ele; // set for next swipe check
00229E  90002E     MOV [W14+4], W0
0022A0  784000     MOV.B W0, W0
0022A2  B7E840     MOV.B WREG, 0x840
438:                           }
439:                       }
440:                   } else {
441:                       // reset swipe status
442:                       swipe_ele = 0x00;
0022AE  EB4000     CLR.B W0
0022B0  B7E840     MOV.B WREG, 0x840
443:                   }
444:               
445:               
446:               
447:                       /*
448:                       char number[ITOASIZE] = "";
449:                       char number2[ITOASIZE] = "";
450:                       unsigned int combined = i2cbyte + ((i2cbyte2 & 0b00011111) << 8);
451:                       itoa(number, combined, 10);
452:                       bool ovcf = false;
453:                       if (i2cbyte2 & 0x80) ovcf = true;
454:               
455:                       // check OOR registers
456:                       i2cbyte =  I2Cread(slaveaddr, 0x02);
457:                       i2cbyte2 = I2Cread(slaveaddr, 0x03);
458:                       unsigned int combined2 = i2cbyte + ((i2cbyte2 & 0b00011111) << 8);
459:                       itoa(number2, combined2, 10);*/
460:               
461:                       
462:               
463:                   /*i2cbyte = I2Cread(slaveaddr, 0x01);
464:               
465:                   if (i2cbyte & 0x80) {
466:                       I2Cwrite(slaveaddr, 0x01, 0x00);    // reset OVCF
467:                       I2Cwrite(slaveaddr, ELE_CFG, 0x0C); // Enable first 12 electrodes
468:                   }*/
469:                   /*if (strcmp(touchdata, "tap") == 0)
470:                   {
471:                       returnval.istap = true;
472:                   }
473:                   else if (strncmp(touchdata, "swipe ", sizeof("swipe ")-1) == 0)
474:                   {
475:                       // get swipe strength
476:                       int strength = atoi(touchdata+sizeof("swipe"));
477:                       // make sure we're sitting on valid data
478:                       // don't declare a swipe unless there's a valid strength
479:                       if (strength > 0) {
480:                           returnval.isswipe = true;
481:                           if (strength > 9) strength = 9; // 1-9 levels
482:                           returnval.swipestrength = strength;
483:                       }
484:                   }*/
485:                   return returnval;
0022B2  90003E     MOV [W14+6], W0
0022B4  9000CE     MOV [W14+8], W1
0022B6  BE8C00     MOV.D W0, [W8]
486:               };
0022B8  780008     MOV W8, W0
0022BA  78044F     MOV [--W15], W8
0022BC  FA8000     ULNK
0022BE  060000     RETURN
487:               
488:               void dbg_touch()
489:               {
0022C0  FA0002     LNK #0x2
490:                   char i2cbyte;
491:                   i2cbyte =  I2Cread(slaveaddr, 0x00);
0022C2  BFC81F     MOV.B slaveaddr, WREG
0022C4  EB4080     CLR.B W1
0022C6  07FEBD     RCALL I2Cread
0022C8  784F00     MOV.B W0, [W14]
492:               
493:                   // ----------  DEBUG CODE  ---------------
494:                   uart_binary(i2cbyte);
0022CA  78401E     MOV.B [W14], W0
0022CC  07FDAA     RCALL uart_binary
495:                   uart_chrstr(" - b");
0022CE  296E80     MOV #0x96E8, W0
0022D0  070384     RCALL uart_chrstr
496:                   i2cbyte =  I2Cread(slaveaddr, 0x01);
0022D2  BFC81F     MOV.B slaveaddr, WREG
0022D4  B3C011     MOV #0x1, W1
0022D6  07FEB5     RCALL I2Cread
0022D8  784F00     MOV.B W0, [W14]
497:                   uart_binary(i2cbyte);
0022DA  78401E     MOV.B [W14], W0
0022DC  07FDA2     RCALL uart_binary
498:                   uart_chrstr(" - c");
0022DE  296ED0     MOV #0x96ED, W0
0022E0  07037C     RCALL uart_chrstr
499:                   i2cbyte =  I2Cread(slaveaddr, 0x02);
0022E2  BFC81F     MOV.B slaveaddr, WREG
0022E4  B3C021     MOV #0x2, W1
0022E6  07FEAD     RCALL I2Cread
0022E8  784F00     MOV.B W0, [W14]
500:                   uart_binary(i2cbyte);
0022EA  78401E     MOV.B [W14], W0
0022EC  07FD9A     RCALL uart_binary
501:                   uart_chrstr(" - d");
0022EE  296F20     MOV #0x96F2, W0
0022F0  070374     RCALL uart_chrstr
502:                   i2cbyte =  I2Cread(slaveaddr, 0x03);
0022F2  BFC81F     MOV.B slaveaddr, WREG
0022F4  B3C031     MOV #0x3, W1
0022F6  07FEA5     RCALL I2Cread
0022F8  784F00     MOV.B W0, [W14]
503:                   uart_binary(i2cbyte);
0022FA  78401E     MOV.B [W14], W0
0022FC  07FD92     RCALL uart_binary
504:                   uart_chrstr(" - e");
0022FE  296F70     MOV #0x96F7, W0
002300  07036C     RCALL uart_chrstr
505:                   i2cbyte =  I2Cread(slaveaddr, ELE_CFG);
002302  BFC81F     MOV.B slaveaddr, WREG
002304  B3C5E1     MOV #0x5E, W1
002306  07FE9D     RCALL I2Cread
002308  784F00     MOV.B W0, [W14]
506:                   uart_binary(i2cbyte);
00230A  78401E     MOV.B [W14], W0
00230C  07FD8A     RCALL uart_binary
507:                   uart_chrstr("\r");
00230E  296FC0     MOV #0x96FC, W0
002310  070364     RCALL uart_chrstr
508:                   // --- END DEBUG CODE ---
509:               }
002312  FA8000     ULNK
002314  060000     RETURN
---  H:/ecen4013/integration2/integration2.X/canbus.c  --------------------------------------------------
1:                 /*
2:                  *
3:                  * Hey, did you hear?
4:                  *
5:                  * A guy (or possibly girl) named Colt wrote this.
6:                  *
7:                  */
8:                 
9:                 #include <p24HJ64GP502.h>
10:                
11:                #include "canbus.h"
12:                #include "logics.h"
13:                
14:                /* Assign 32x8 Word Message Buffers for ECAN1 in DMA RAM */
15:                unsigned int ecan1MsgBuf[32][8] __attribute__((space(dma)));
16:                
17:                
18:                void CAN_init()
19:                {
002BB0  FA0000     LNK #0x0
20:                    // request config mode
21:                    C1CTRL1bits.REQOP=4;
002BB2  802001     MOV C1CTRL1, W1
002BB4  2F8FF0     MOV #0xF8FF, W0
002BB6  608080     AND W1, W0, W1
002BB8  204000     MOV #0x400, W0
002BBA  708000     IOR W1, W0, W0
002BBC  882000     MOV W0, C1CTRL1
22:                    while (C1CTRL1bits.OPMODE != 4) {};
002BBE  000000     NOP
002BC0  802001     MOV C1CTRL1, W1
002BC2  200E00     MOV #0xE0, W0
002BC4  608080     AND W1, W0, W1
002BC6  200800     MOV #0x80, W0
002BC8  508F80     SUB W1, W0, [W15]
002BCA  3AFFFA     BRA NZ, 0x2BC0
23:                    // (remappable pins set in IO_init())
24:                
25:                    // ----- set clock timing -----
26:                    C1CFG1bits.BRP = CAN_BRP;   // see header
002BCC  802081     MOV C1CFG1, W1
002BCE  2FFC00     MOV #0xFFC0, W0
002BD0  608000     AND W1, W0, W0
002BD2  B30030     IOR #0x3, W0
002BD4  882080     MOV W0, C1CFG1
27:                    C1CFG1bits.SJW = 0x0;       // set synch jump to 1xTQ
002BD6  802081     MOV C1CFG1, W1
002BD8  2FF3F0     MOV #0xFF3F, W0
002BDA  608000     AND W1, W0, W0
002BDC  882080     MOV W0, C1CFG1
28:                    C1CFG2bits.WAKFIL = 0;
002BDE  A9C413     BCLR 0x413, #6
29:                    C1CFG2bits.SAM = 0x1;       // bus line sampled 3 times at sample point
002BE0  A8C412     BSET C1CFG2, #6
30:                    C1CFG2bits.SEG2PHTS = 0x1;  // phase2 time select bit
002BE2  A8E412     BSET C1CFG2, #7
31:                    C1CFG2bits.SEG1PH = 0x0;    // phase segment 1 is 1xTQ
002BE4  802091     MOV C1CFG2, W1
002BE6  2FFC70     MOV #0xFFC7, W0
002BE8  608000     AND W1, W0, W0
002BEA  882090     MOV W0, C1CFG2
32:                    C1CFG2bits.PRSEG = 0x3;     // propagation time to 4xTQ
002BEC  802091     MOV C1CFG2, W1
002BEE  2FFF80     MOV #0xFFF8, W0
002BF0  608000     AND W1, W0, W0
002BF2  B30030     IOR #0x3, W0
002BF4  882090     MOV W0, C1CFG2
33:                    C1CFG2bits.SEG2PH = 0x1;    // phase segment 2 is 2xTQ
002BF6  802091     MOV C1CFG2, W1
002BF8  2F8FF0     MOV #0xF8FF, W0
002BFA  608080     AND W1, W0, W1
002BFC  201000     MOV #0x100, W0
002BFE  708000     IOR W1, W0, W0
002C00  882090     MOV W0, C1CFG2
34:                
35:                    // buffer size
36:                    // C1FCTRLbits.DMABS
37:                
38:                    // ----- set receive filters -----
39:                    C1CTRL1bits.WIN = 1; // set window to receive filters
002C02  A80400     BSET C1CTRL1, #0
40:                    // create filter
41:                    C1RXF0SIDbits.SID = 0x000;  // 11-bit SID to match
002C04  802200     MOV C1RXD, W0
002C06  60007F     AND W0, #0x1F, W0
002C08  882200     MOV W0, C1RXD
42:                    C1RXF0SIDbits.EXIDE = 0b0;  // match only standard identifier messages
002C0A  A96440     BCLR C1RXD, #3
43:                    C1BUFPNT1bits.F0BP = 0x1;   // put filter 0 hits into rx buffer 1
002C0C  802101     MOV C1RXFUL1, W1
002C0E  2FFF00     MOV #0xFFF0, W0
002C10  608000     AND W1, W0, W0
002C12  A00000     BSET W0, #0
002C14  882100     MOV W0, C1RXFUL1
44:                    C1FMSKSEL1bits.F0MSK = 0x0; // select mask 0 for filter 0
002C16  8020C1     MOV C1FMSKSEL1, W1
002C18  2FFFC0     MOV #0xFFFC, W0
002C1A  608000     AND W1, W0, W0
002C1C  8820C0     MOV W0, C1FMSKSEL1
45:                    // create mask
46:                    C1RXM0SIDbits.SID = 0x700;  // mask top three bits to make sure they are zero (aka 8-bit SID) // mask NO bits (aka accept all)
002C1E  802180     MOV C1TR01CON, W0
002C20  6000FF     AND W0, #0x1F, W1
002C22  2E0000     MOV #0xE000, W0
002C24  708000     IOR W1, W0, W0
002C26  882180     MOV W0, C1TR01CON
47:                    C1RXM0SIDbits.MIDE = 0b1;   // match message type of EXIDE bit (standard)
002C28  A86430     BSET C1TR01CON, #3
48:                    // enable filter
49:                    C1FEN1bits.FLTEN = 0x0001;  // disable all filters except filter 0
002C2A  200010     MOV #0x1, W0
002C2C  8820A0     MOV W0, C1FEN1
50:                
51:                    // done with receive filters, set window back
52:                    C1CTRL1bits.WIN = 0;
002C2E  A90400     BCLR C1CTRL1, #0
53:                
54:                    // done with config, set to normal mode
55:                    C1CTRL1bits.REQOP = 0b000;
002C30  802001     MOV C1CTRL1, W1
002C32  2F8FF0     MOV #0xF8FF, W0
002C34  608000     AND W1, W0, W0
002C36  882000     MOV W0, C1CTRL1
56:                    while (C1CTRL1bits.OPMODE != 0) {}; // wait to settle down
002C38  000000     NOP
002C3A  802001     MOV C1CTRL1, W1
002C3C  200E00     MOV #0xE0, W0
002C3E  608000     AND W1, W0, W0
002C40  500FE0     SUB W0, #0x0, [W15]
002C42  3AFFFB     BRA NZ, 0x2C3A
57:                
58:                    // go into loopback mode for testing
59:                    //C1CTRL1bits.REQOP = 0b010;
60:                    //while (C1CTRL1bits.OPMODE != 0b010) {};
61:                
62:                    // ----- initialize DMA for transmit -----
63:                    DMA0CONbits.SIZE = 0x0;  // Transfer Size: Word Transfer Mode
002C44  A9C381     BCLR 0x381, #6
64:                    DMA0CONbits.DIR = 0x1;   // Transfer Direction: DMA RAM to Peripheral
002C46  A8A381     BSET 0x381, #5
65:                    DMA0CONbits.AMODE = 0x2; // Addressing Mode: Peripheral Indirect
002C48  801C01     MOV DMA0CON, W1
002C4A  2FFCF0     MOV #0xFFCF, W0
002C4C  608080     AND W1, W0, W1
002C4E  200200     MOV #0x20, W0
002C50  708000     IOR W1, W0, W0
002C52  881C00     MOV W0, DMA0CON
66:                    DMA0CONbits.MODE = 0x0;  // Operating Mode: Continuous, Ping-Pong modes disabled
002C54  801C01     MOV DMA0CON, W1
002C56  2FFFC0     MOV #0xFFFC, W0
002C58  608000     AND W1, W0, W0
002C5A  881C00     MOV W0, DMA0CON
67:                    DMA0REQ = 70;            // Assign ECAN1 Transmit event for DMA Channel 0
002C5C  200460     MOV #0x46, W0
002C5E  881C10     MOV W0, DMA0REQ
68:                    DMA0CNT = 7;             // Set Number of DMA Transfer per ECAN message to 8 words
002C60  200070     MOV #0x7, W0
002C62  881C50     MOV W0, DMA0CNT
69:                    DMA0PAD = 0x0442; //&C1TXD;         // Peripheral Address: ECAN1 Transmit Register
002C64  204420     MOV #0x442, W0
002C66  881C40     MOV W0, DMA0PAD
70:                    /* Start Address Offset for ECAN1 Message Buffer 0x0000 */
71:                    DMA0STA = __builtin_dmaoffset(ecan1MsgBuf);
002C68  206000     MOV #0x600, W0
002C6A  881C20     MOV W0, DMA0STA
72:                    DMA0CONbits.CHEN = 0x1;  // Channel Enable: Enable DMA Channel 0
002C6C  A8E381     BSET 0x381, #7
73:                    // ? IEC0bits.DMA0IE = 1;     // Interrupt Enable: Enable DMA Channel 0 Interrupt
74:                
75:                    // ----- initialize DMA for receive -----
76:                    DMA1CONbits.SIZE = 0x0;  // Transfer Size: Word Transfer Mode
002C6E  A9C38D     BCLR 0x38D, #6
77:                    DMA1CONbits.DIR = 0x0;   // Transfer Direction: Peripheral to DMA RAM
002C70  A9A38D     BCLR 0x38D, #5
78:                    DMA1CONbits.AMODE = 0x2; // Addressing Mode: Peripheral Indirect
002C72  801C61     MOV DMA1CON, W1
002C74  2FFCF0     MOV #0xFFCF, W0
002C76  608080     AND W1, W0, W1
002C78  200200     MOV #0x20, W0
002C7A  708000     IOR W1, W0, W0
002C7C  881C60     MOV W0, DMA1CON
79:                    DMA1CONbits.MODE = 0x0;  // Operating Mode: Continuous, Ping-Pong modes disabled
002C7E  801C61     MOV DMA1CON, W1
002C80  2FFFC0     MOV #0xFFFC, W0
002C82  608000     AND W1, W0, W0
002C84  881C60     MOV W0, DMA1CON
80:                    DMA1REQ = 34;            // Assign ECAN1 Receive event for DMA Channel 1
002C86  200220     MOV #0x22, W0
002C88  881C70     MOV W0, DMA1REQ
81:                    DMA1CNT = 7;             // Set Number of DMA Transfer per ECAN message to 8 words
002C8A  200070     MOV #0x7, W0
002C8C  881CB0     MOV W0, DMA1CNT
82:                    DMA1PAD = 0x0440; //&C1RXD;        // Peripheral Address: ECAN1 Receive Register
002C8E  204400     MOV #0x440, W0
002C90  881CA0     MOV W0, DMA1PAD
83:                    /* Start Address Offset for ECAN1 Message Buffer 0x0000 */
84:                    DMA1STA = __builtin_dmaoffset(ecan1MsgBuf);
002C92  206000     MOV #0x600, W0
002C94  881C80     MOV W0, DMA1STA
85:                    DMA1CONbits.CHEN = 0x1;  // Channel Enable: Enable DMA Channel 1
002C96  A8E38D     BSET 0x38D, #7
86:                    //IEC0bits.DMA1IE = 1;     //Channel Interrupt Enable: Enable DMA Channel 1 Interrupt
87:                
88:                
89:                    // also this came from example 21-1 "standard data frame transmission"
90:                    // see figure 21-8
91:                
92:                    /* Assign 32x8word Message Buffers for ECAN1 in DMA RAM */
93:                    //unsigned int ecan1MsgBuf[32][8] __attribute__((space(dma)));
94:                    // ? DMA1STA = __builtin_dmaoffset(ecan1MsgBuf);
95:                    /* Configure Message Buffer 2 for Transmission and assign priority */
96:                    C1TR01CONbits.TXEN0 = 0x1;
002C98  A8E430     BSET C1TR01CON, #7
97:                    C1TR01CONbits.TXEN1 = 0x0; // buff 1 is receive
002C9A  A9E431     BCLR 0x431, #7
98:                    C1TR01CONbits.TX0PRI = 0x3;
002C9C  802180     MOV C1TR01CON, W0
002C9E  B30030     IOR #0x3, W0
002CA0  882180     MOV W0, C1TR01CON
99:                    C1TR01CONbits.TX1PRI = 0x3;
002CA2  802181     MOV C1TR01CON, W1
002CA4  203000     MOV #0x300, W0
002CA6  708000     IOR W1, W0, W0
002CA8  882180     MOV W0, C1TR01CON
100:               
101:                   
102:               
103:                   // whelp let's send a connection request to the HIU
104:                   //CANtx(0x02, DEVICE_ID, 0x01, 0x00, 0x00);
105:               
106:               }
002CAA  FA8000     ULNK
002CAC  060000     RETURN
107:               
108:               
109:               bool im_dead() {
002CAE  FA0000     LNK #0x0
110:                   uart_chrstr("you're totally dead, dude.");
002CB0  297260     MOV #0x9726, W0
002CB2  07FE93     RCALL uart_chrstr
111:                   uart_newline();
002CB4  07FE7F     RCALL uart_newline
112:               
113:                   // whelp let's send a connection request to the HIU
114:                   //CANtx(0x02, DEVICE_ID, 0x01, 0x00, 0x00); // for testing
115:                   CANtx(0x00, 0x00, 0x00, 0x02, 0x04); // for testing
002CB6  B3C044     MOV #0x4, W4
002CB8  B3C023     MOV #0x2, W3
002CBA  EB4100     CLR.B W2
002CBC  EB4080     CLR.B W1
002CBE  EB4000     CLR.B W0
002CC0  070003     RCALL CANtx
116:               
117:                   // this is the im dead packet
118:                   //CANtx(0x03, DEVICE_ID, 0xFE, 0x00, 0x00);
119:               
120:                   return true; // hahaha, punk
002CC2  B3C010     MOV #0x1, W0
121:               }
002CC4  FA8000     ULNK
002CC6  060000     RETURN
122:               
123:               
124:               
125:               void CANtx(unsigned char SIDH, // SIDH is the top 8 bits of 11-bit SID.
126:                                              // aka "MSG ID" in MCAN payload specs.
127:                          unsigned char d0, unsigned char d1,
128:                          unsigned char d2, unsigned char d3)
129:               {
002CC8  FA0006     LNK #0x6
002CCA  784F00     MOV.B W0, [W14]
002CCC  984711     MOV.B W1, [W14+1]
002CCE  984722     MOV.B W2, [W14+2]
002CD0  984733     MOV.B W3, [W14+3]
002CD2  984744     MOV.B W4, [W14+4]
130:                   // see the MCAN payload specs on mage.okstate.edu
131:               
132:                   /* can transmit code from DS70185 */
133:               
134:                   
135:                   /* WRITE TO MESSAGE BUFFER 0 */
136:                   // cmw; see buffers in section 21.4 of DS70185
137:               
138:                   /* CiTRBnSID = 0bxxx1 0010 0011 1100
139:                   IDE = 0b0
140:                   SRR = 0b0
141:                   SID<10:0>= 0b100 1000 1111 */
142:                   //ecan1MsgBuf[0][0] = 0x123C;
143:                   ecan1MsgBuf[0][0] = 0x0000 | (SIDH << 5); // top 8 bits of SID, bitshift.
002CD4  78409E     MOV.B [W14], W1
002CD6  FB8001     ZE W1, W0
002CD8  DD0045     SL W0, #5, W0
002CDA  893000     MOV W0, ecan1MsgBuf
144:                   /* CiTRBnEID = 0bxxxx 0000 0000 0000
145:                   EID<17:6> = 0b0000 0000 0000 */
146:                   ecan1MsgBuf[0][1] = 0x0000; // extended identifier, set to 0.
002CDC  EB0000     CLR W0
002CDE  893010     MOV W0, 0x2602
147:                   /* CiTRBnDLC = 0b0000 0000 xxx0 1111
148:                   EID<5:0> = 0b000000
149:                   RTR = 0b0
150:                   RB1 = 0b0
151:                   RB0 = 0b0
152:                   DLC = 0b1000 */
153:                   ecan1MsgBuf[0][2] = 0x4; // sending four bytes (8 for testing)
002CE0  200040     MOV #0x4, W0
002CE2  893020     MOV W0, 0x2604
154:                   /* WRITE MESSAGE DATA BYTES */
155:                   ecan1MsgBuf[0][3] = (d1 << 8) | d0;
002CE4  90402E     MOV.B [W14+2], W0
002CE6  FB8000     ZE W0, W0
002CE8  DD00C8     SL W0, #8, W1
002CEA  90401E     MOV.B [W14+1], W0
002CEC  FB8000     ZE W0, W0
002CEE  708000     IOR W1, W0, W0
002CF0  893030     MOV W0, 0x2606
156:                   ecan1MsgBuf[0][4] = (d3 << 8) | d2;
002CF2  90404E     MOV.B [W14+4], W0
002CF4  FB8000     ZE W0, W0
002CF6  DD00C8     SL W0, #8, W1
002CF8  90403E     MOV.B [W14+3], W0
002CFA  FB8000     ZE W0, W0
002CFC  708000     IOR W1, W0, W0
002CFE  893040     MOV W0, 0x2608
157:                   ecan1MsgBuf[0][5] = 0xabcd; // shouldn't care about setting these two.
002D00  2ABCD0     MOV #0xABCD, W0
002D02  893050     MOV W0, 0x260A
158:                   ecan1MsgBuf[0][6] = 0xabcd;
002D04  2ABCD0     MOV #0xABCD, W0
002D06  893060     MOV W0, 0x260C
159:                   /* REQUEST MESSAGE BUFFER 0 TRANSMISSION */
160:                   C1TR01CONbits.TXREQ0 = 0x1;
002D08  A86430     BSET C1TR01CON, #3
161:               
162:               };
002D0A  FA8000     ULNK
002D0C  060000     RETURN
163:               
164:               
165:               int CANrx()
166:               {
002D0E  FA0002     LNK #0x2
167:                   int val = -1;
002D10  EB8000     SETM W0
002D12  780F00     MOV W0, [W14]
168:                   // -1 if no packet
169:                   // # if packet received, # is index of ecan1MsgBuf[n][0-7]
170:                   if (C1RXFUL1bits.RXFUL0) // only filter enabled is filter 0
002D14  802100     MOV C1RXFUL1, W0
002D16  600061     AND W0, #0x1, W0
002D18  500FE0     SUB W0, #0x0, [W15]
002D1A  320007     BRA Z, 0x2D2A
171:                   {
172:                       C1CTRL1bits.WIN = 1; // set window to access
002D1C  A80400     BSET C1CTRL1, #0
173:                       val = C1BUFPNT1bits.F0BP; // buffer set for filter 0
002D1E  802100     MOV C1RXFUL1, W0
002D20  784000     MOV.B W0, W0
002D22  60406F     AND.B W0, #0xF, W0
002D24  FB8000     ZE W0, W0
002D26  780F00     MOV W0, [W14]
174:                       C1CTRL1bits.WIN = 0;
002D28  A90400     BCLR C1CTRL1, #0
175:                   }
176:                   return val;
002D2A  78001E     MOV [W14], W0
177:               }
002D2C  FA8000     ULNK
002D2E  060000     RETURN
---  H:/ecen4013/integration2/integration2.X/audio.c  ---------------------------------------------------
1:                 
2:                 /*
3:                  * File:   newmain.c
4:                  * Author: Ahmed
5:                  *
6:                  * Created on March 23, 2014, 3:40 PM
7:                  */
8:                 
9:                 #include <stdio.h>
10:                #include <stdlib.h>
11:                #include <p24HJ64GP502.h>
12:                
13:                #include "logics.h"
14:                
15:                
16:                /*int Track_1[8] = {1,1,1,1,1,1,1,0};
17:                int Track_2[8] = {1,1,1,1,1,1,0,1};
18:                int Track_3[8] = {1,1,1,1,1,0,1,1};
19:                int Track_4[8] = {1,1,1,1,0,1,1,1};
20:                int Track_5[8] = {1,1,1,0,1,1,1,1};
21:                int Track_6[8] = {1,1,0,1,1,1,1,1};
22:                
23:                
24:                void delay(int i){
25:                
26:                    int k=1;
27:                    while(k <= i){
28:                        Nop();
29:                        k++;
30:                    }
31:                
32:                }
33:                
34:                //void play_song(int song[8])
35:                void play_sound(int soundnumber)
36:                {
37:                    int counter;
38:                    //int bitCount =0;
39:                    int bitCount =1;
40:                    for (counter =0; counter <8; counter++){
41:                        aud_clk =0;
42:                        //delay(1000);
43:                        //if(song[bitCount] == 0){
44:                        if (soundnumber == 9-bitCount) {
45:                            aud_data = 0;
46:                        }
47:                        else{
48:                            aud_data = 1;
49:                        }
50:                        aud_clk=1;
51:                        //delay(1000);
52:                        bitCount++;
53:                    }
54:                }*/
55:                
56:                void audio_init()
57:                {
002E1C  FA0002     LNK #0x2
58:                    int i;
59:                    aud_clk = 1;
002E1E  A842CC     BSET LATB, #2
60:                    aud_data = 1;
002E20  A862CC     BSET LATB, #3
61:                    aud_res = 1;
002E22  A842C4     BSET LATA, #2
62:                    for(i = 0; i < 18425; i++)  // 5 ms?
002E24  EB0000     CLR W0
002E26  780F00     MOV W0, [W14]
002E28  370002     BRA 0x2E2E
002E2C  E80F1E     INC [W14], [W14]
002E2E  247F80     MOV #0x47F8, W0
002E30  78009E     MOV [W14], W1
002E32  508F80     SUB W1, W0, [W15]
002E34  34FFFA     BRA LE, 0x2E2A
63:                        Nop();
002E2A  000000     NOP
64:                    aud_res = 0;
002E36  A942C4     BCLR LATA, #2
65:                    for(i = 0; i < 18425; i++)  // 5 ms?
002E38  EB0000     CLR W0
002E3A  780F00     MOV W0, [W14]
002E3C  370002     BRA 0x2E42
002E40  E80F1E     INC [W14], [W14]
002E42  247F80     MOV #0x47F8, W0
002E44  78009E     MOV [W14], W1
002E46  508F80     SUB W1, W0, [W15]
002E48  34FFFA     BRA LE, 0x2E3E
66:                        Nop();
002E3E  000000     NOP
67:                    aud_res = 1;
002E4A  A842C4     BSET LATA, #2
68:                    //sdi_out(0xFFF1); // second lowest volume level? (FFF0 min, FFF7 max)
69:                    // FFFE play/pause
70:                    // FFFF stop
71:                    // 0000 to 00FF play file (0000.ad4 to 0511.ad4)
72:                    /*int j;
73:                    for(j = 0; j < 60; j++) // 300 ms total?
74:                    {
75:                        for(i = 0; i < 18425; i++)  // 5 ms?
76:                            Nop();
77:                    }*/
78:                
79:                }
002E4C  FA8000     ULNK
002E4E  060000     RETURN
80:                void sdi_out(int value)
81:                {
002E50  FA0006     LNK #0x6
002E52  980720     MOV W0, [W14+4]
82:                    int i, j;
83:                
84:                    aud_clk = 1;
002E54  A842CC     BSET LATB, #2
85:                    aud_clk = 0;
002E56  A942CC     BCLR LATB, #2
86:                    // wait 2 ms? (to pull out of sleep mode)
87:                    for(i = 0; i < 16370; i++)
002E58  EB0000     CLR W0
002E5A  780F00     MOV W0, [W14]
002E5C  370002     BRA 0x2E62
002E60  E80F1E     INC [W14], [W14]
002E62  23FF10     MOV #0x3FF1, W0
002E64  78009E     MOV [W14], W1
002E66  508F80     SUB W1, W0, [W15]
002E68  34FFFA     BRA LE, 0x2E5E
88:                    {
89:                        Nop();
002E5E  000000     NOP
90:                    }
91:                    for(i = 0; i < 16; i++)
002E6A  EB0000     CLR W0
002E6C  780F00     MOV W0, [W14]
002E6E  370029     BRA 0x2EC2
002EC0  E80F1E     INC [W14], [W14]
002EC2  78001E     MOV [W14], W0
002EC4  500FEF     SUB W0, #0xF, [W15]
002EC6  34FFD4     BRA LE, 0x2E70
92:                    {
93:                        //
94:                        aud_clk = 0;
002E70  A942CC     BCLR LATB, #2
95:                        // msb first
96:                        aud_data = (value >> (15-i)) & 0x01;
002E72  2000F1     MOV #0xF, W1
002E74  50801E     SUB W1, [W14], W0
002E76  9000AE     MOV [W14+4], W1
002E78  DE8800     ASR W1, W0, W0
002E7A  784000     MOV.B W0, W0
002E7C  604061     AND.B W0, #0x1, W0
002E7E  604061     AND.B W0, #0x1, W0
002E80  604061     AND.B W0, #0x1, W0
002E82  FB8000     ZE W0, W0
002E84  600061     AND W0, #0x1, W0
002E86  DD0043     SL W0, #3, W0
002E88  801662     MOV LATB, W2
002E8A  2FFF71     MOV #0xFFF7, W1
002E8C  610081     AND W2, W1, W1
002E8E  708000     IOR W1, W0, W0
002E90  881660     MOV W0, LATB
97:                        for(j = 0; j < 368; j++) // 200 us? // 737
002E92  EB0000     CLR W0
002E94  980710     MOV W0, [W14+2]
002E96  370004     BRA 0x2EA0
002E9A  90001E     MOV [W14+2], W0
002E9C  E80000     INC W0, W0
002E9E  980710     MOV W0, [W14+2]
002EA0  90009E     MOV [W14+2], W1
002EA2  2016F0     MOV #0x16F, W0
002EA4  508F80     SUB W1, W0, [W15]
002EA6  34FFF8     BRA LE, 0x2E98
98:                            Nop();
002E98  000000     NOP
99:                        aud_clk = 1;
002EA8  A842CC     BSET LATB, #2
100:                       for(j = 0; j < 368; j++) // 200 us? // 1474
002EAA  EB0000     CLR W0
002EAC  980710     MOV W0, [W14+2]
002EAE  370004     BRA 0x2EB8
002EB2  90001E     MOV [W14+2], W0
002EB4  E80000     INC W0, W0
002EB6  980710     MOV W0, [W14+2]
002EB8  90009E     MOV [W14+2], W1
002EBA  2016F0     MOV #0x16F, W0
002EBC  508F80     SUB W1, W0, [W15]
002EBE  34FFF8     BRA LE, 0x2EB0
101:                           Nop();
002EB0  000000     NOP
102:                   }
103:                   aud_data = 1;
002EC8  A862CC     BSET LATB, #3
104:               }
002ECA  FA8000     ULNK
002ECC  060000     RETURN
105:               
106:               // sound logic
107:               void play_sound(int soundnumber)
108:               {
002ECE  FA0014     LNK #0x14
002ED0  980F10     MOV W0, [W14+18]
109:                   char number[ITOASIZE] = "";
002ED2  B80060     MUL.UU W0, #0, W0
002ED4  BE8F00     MOV.D W0, [W14]
002ED6  78000E     MOV W14, W0
002ED8  B00040     ADD #0x4, W0
002EDA  090005     REPEAT #0x5
002EDC  EB1800     CLR [W0++]
002EDE  EB5800     CLR.B [W0++]
110:                   itoa(number, soundnumber, 10);
002EE0  2000A2     MOV #0xA, W2
002EE2  90089E     MOV [W14+18], W1
002EE4  78000E     MOV W14, W0
002EE6  07E9F0     RCALL _itoa
111:                   uart_chrstr("playing sound ");
002EE8  297420     MOV #0x9742, W0
002EEA  07FD77     RCALL uart_chrstr
112:                   uart_chrstr(number);
002EEC  78000E     MOV W14, W0
002EEE  07FD75     RCALL uart_chrstr
113:                   uart_newline();
002EF0  07FD61     RCALL uart_newline
114:               
115:                   //sdi_out(0xFFF7);
116:                   sdi_out(soundnumber);
002EF2  90081E     MOV [W14+18], W0
002EF4  07FFAD     RCALL sdi_out
117:               };
002EF6  FA8000     ULNK
002EF8  060000     RETURN
118:               
119:               /*void play_sound(int soundnumber)
120:               {
121:                   char number[ITOASIZE] = "";
122:                   itoa(number, soundnumber, 10);
123:                   uart_chrstr("playing sound ");
124:                   uart_chrstr(number);
125:                   uart_newline();
126:               
127:                   switch (soundnumber) {
128:                       case AUD_FIRE:
129:                           play_song(Track_1);
130:                           break;
131:                       case AUD_LOAD:
132:                           play_song(Track_2);
133:                           break;
134:                       case AUD_HIT:
135:                           play_song(Track_3);
136:                           break;
137:                       case AUD_COOLDOWN:
138:                           play_song(Track_4);
139:                           break;
140:                       case AUD_DEAD:
141:                           play_song(Track_5);
142:                           break;
143:                       case AUD_START:
144:                           play_song(Track_6);
145:                           break;
146:                   }
147:               
148:               }*/
